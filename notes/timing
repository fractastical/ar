Timing notes
============

*   Boyer-Moore is faster than Arc's posmatch with small pattern strings:

        > (timeit (posmatch "foo" "barfoo"))
        iter: 423,974  gc: 760  mem: -19140888

        > (timeit (boyer-posmatch "foo" "barfoo"))
        iter: 585,847  gc: 140  mem: -74992

*   Due to preprocessing, the situation is reversed with long pattern strings:

        > (timeit (posmatch "foobarquxcorgenou" "adadadadadadadadadadadadadad"))
        iter: 248,074  gc: 368  mem: 4458200

        > (timeit (boyer-posmatch "foobarquxcorgenou" "adadadadadadadadadadadadadad"))
        iter: 164,709  gc: 112  mem: -10014592

*   But, when precomputing the pattern, Boyer-Moore is *drastically* faster:

        > (let x (boyer-moore-process "foobarquxcorgenou")
            (timeit (boyer-moore-search x "adadadadadadadadadadadadadad")))
        iter: 1,758,602  gc: 124  mem: -5842336


        > (timeit (posmatch "Chrono Cross CrossFire OC ReMix"
                            "lists/Chrono Cross/Remix/Chrono Cross CrossFire OC ReMix.mp3"))
        iter: 69,847  gc: 205  mem: 14991456

        > (timeit (boyer-posmatch "Chrono Cross CrossFire OC ReMix"
                                  "lists/Chrono Cross/Remix/Chrono Cross CrossFire OC ReMix.mp3"))
        iter: 51,026  gc: 116  mem: 11917568

        > (let x (boyer-moore-process "Chrono Cross CrossFire OC ReMix")
            (timeit (boyer-moore-search x "lists/Chrono Cross/Remix/Chrono Cross CrossFire OC ReMix.mp3")))
        iter: 170,348  gc: 124  mem: -16630560


*   Boyer-Moore is also faster for multi-string searches:

        > (with (string "ufobarquxcorge"
                 pats   '("foo" "bar" "qux"))
            (timeit (reclist (fn (x) (posmatch car.x string)) pats)))
        iter: 153,900  gc: 352  mem: 7072440

        > (let x (boyer-moore-process "foo" "bar" "qux")
            (timeit (boyer-moore-search x "ufobarquxcorge")))
        iter: 288,369  gc: 148  mem: -5091232


        > (with (string "ufoobarquxcorge"
                 pats   '("foo" "bar" "qux"))
            (timeit (reclist (fn (x) (posmatch car.x string)) pats)))
        iter: 554,319  gc: 580  mem: 4115784

        > (let x (boyer-moore-process "foo" "bar" "qux")
            (timeit (boyer-moore-search x "ufoobarquxcorge")))
        iter: 727,511  gc: 448  mem: -1464704


        > (timeit (multi-match '("foo" "bar" "qux") '("corge" "foo" "bar" "qux")))
        iter: 56,169  gc: 948  mem: -23564104

        > (timeit (boyer-multi-match '("foo" "bar" "qux") '("corge" "foo" "bar" "qux")))
        iter: 84,598  gc: 136  mem: 4189208

        > (let x (map boyer-moore-process '("foo" "bar" "qux"))
            (timeit (boyer-multi-match1 x '("corge" "foo" "bar" "qux"))))
        iter: 108,929  gc: 124  mem: -104176


        > (timeit (multi-match '("foo" "bar" "qux") '("ufoobarquxcorge")))
        iter: 357,005  gc: 484  mem: -103664

        > (timeit (boyer-multi-match '("foo" "bar" "qux") '("ufoobarquxcorge")))
        iter: 214,963  gc: 128  mem: 16251304

        > (let x (map boyer-moore-process '("foo" "bar" "qux"))
            (timeit (boyer-multi-match1 x '("ufoobarquxcorge"))))
        iter: 471,928  gc: 116  mem: 21216504

*   Inlining function values gives a noticable speed boost:

        (eval `(ac-funcall2 + 1 2))   -> 9211 ms
        (eval `(,ac-funcall2 + 1 2))  -> 5321 ms
        (eval `(,ac-funcall2 ,+ 1 2)) -> 4108 ms

*   `make-keyword-procedure` is about twice as slow as a normal `lambda`:

        > (timeit (%nocompile ((racket-make-keyword-procedure (racket-lambda (kw kw-val . rest) rest)) 1 2 3)))
        time: 18.043  gc: 0.856  mem: 2992.04

        > (timeit (%nocompile ((racket-lambda rest rest) 1 2 3)))
        time:  9.149  gc: 0.1    mem: -8635.272


        > (timeit (%nocompile ((racket-make-keyword-procedure (racket-lambda (kw kw-val a) a)) 1)))
        time: 13.35   gc: 0.38   mem: 645.072

        > (timeit (%nocompile ((racket-lambda (a) a) 1)))
        time:  7.957  gc: 0.004  mem: -14541.976

    But it has a much smaller cost when the function is created only once:

        > (let foo (%nocompile (racket-make-keyword-procedure (racket-lambda (kw kw-val a) a)))
            (timeit (%nocompile (foo 1))))
        time: 9.565  gc: 0.032  mem: -2701.456

        > (let foo (%nocompile (racket-lambda (a) a))
            (timeit (%nocompile (foo 1))))
        time: 7.99   gc: 0.0    mem: 97.504


*   `keyword-apply` is *very comparable* in speed to a normal `apply`:

        > (let foo (%nocompile (racket-lambda rest rest))
            (timeit (%nocompile (racket-keyword-apply foo nil nil (racket-list 1 2 3)))))
        time: 12.951 gc: 0.388 mem: -1748.512

        > (let foo (%nocompile (racket-lambda rest rest))
            (timeit (%nocompile (racket-apply foo (racket-list 1 2 3)))))
        time: 12.692 gc: 0.536 mem: -10373.568


        > (let foo (%nocompile (racket-lambda (#:b (b nil) . rest) rest))
            (timeit (%nocompile (racket-keyword-apply foo nil nil (racket-list 1 2 3)))))
        time: 15.309 gc: 0.536 mem: -1729.12

        > (let foo (%nocompile (racket-lambda (#:b (b nil) . rest) rest))
            (timeit (%nocompile (racket-apply foo (racket-list 1 2 3)))))
        time: 14.282 gc: 0.356 mem: -1215.76

*   Keyword functions are almost twice as slow as normal functions:

        > (let foo (fn (:a :b) (list a b))
            (timeit (foo :a 1 :b 2)))
        time: 17.521  gc: 0.408  mem: 2303.568

        > (let foo (fn (a b) (list a b))
            (timeit (foo 1 2)))
        time:  9.515  gc: 0.3    mem: -22736.128


*   Using `%nocompile` is slow because it calls `ac-mappend`:

        Special forms with %nocompile: 3462ms
        Special forms with ac-compile: 2340ms

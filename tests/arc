;=============================================================================
;  fn
;=============================================================================

> (fn ())
#<fn>

> ((fn ()))
nil

> (fn (x) 5)
#<fn>

> ((fn (x) 5))
error: #<procedure>: expects 1 argument, given 0

> ((fn (x) 5) 10)
5

> ((fn (a (b) c) (list a b c)) 1)
error: #<procedure>: expects 3 arguments, given 1: 1

> ((fn (a (b) c) (list a b c)) 1 2)
error: #<procedure>: expects 3 arguments, given 2: 1 2

> ((fn (a (b) c) (list a b c)) 1 2 3)
error: car: expects argument of type <mutable-pair>; given 2

> ((fn (a (b) c) (list a b c)) 1 '(2) 3)
(1 2 3)

> ((fn (a (b) c) (list a b c)) 1 '(2 4) 3)
(1 2 3)


> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)))
error: #<case-lambda-procedure>: no clause matching 0 arguments

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1)
error: #<case-lambda-procedure>: no clause matching 1 argument: 1

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 2)
error: car: expects argument of type <mutable-pair>; given 2

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2))
(1 2 5 nil nil)

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2 3))
(1 2 5 nil nil)

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2 (3)))
(1 2 5 nil nil)

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2 (3)) nil)
(1 2 nil nil nil)

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2 (3)) nil nil)
(1 2 nil nil nil)

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2 (3)) nil nil 5 6 7)
(1 2 nil nil (5 6 7))

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2 (3)) 3)
(1 2 3 nil nil)

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2 (3)) 3 4)
(1 2 3 4 nil)

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2 (3)) 3 4 5)
(1 2 3 4 (5))

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2 (3)) 3 4 5 6)
(1 2 3 4 (5 6))

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2 (3)) 3 4 5 6 7)
(1 2 3 4 (5 6 7))


> ((fn (a (b (c d (e)))) (list a b c d e)) 1 2)
error: car: expects argument of type <mutable-pair>; given 2

> ((fn (a (b (c d (e)))) (list a b c d e)) 1 '(2))
(1 2 nil nil nil)

> ((fn (a (b (c d (e)))) (list a b c d e)) 1 '(2 3))
error: car: expects argument of type <mutable-pair>; given 3

> ((fn (a (b (c d (e)))) (list a b c d e)) 1 '(2 (3)))
(1 2 3 nil nil)

> ((fn (a (b (c d (e)))) (list a b c d e)) 1 '(2 (3 4)))
(1 2 3 4 nil)

> ((fn (a (b (c d (e)))) (list a b c d e)) 1 '(2 (3 4 5)))
error: car: expects argument of type <mutable-pair>; given 5

> ((fn (a (b (c d (e)))) (list a b c d e)) 1 '(2 (3 4 (5))))
(1 2 3 4 5)


> ((fn (a (b (c d (e) f)) . g) (list a b c d e f g)) 1 2)
error: car: expects argument of type <mutable-pair>; given 2

> ((fn (a (b (c d (e) f)) . g) (list a b c d e f g)) 1 '(2 (3 4)))
(1 2 3 4 nil nil nil)

> ((fn (a (b (c d (e) f)) . g) (list a b c d e f g)) 1 '(2 (3 4 5)))
error: car: expects argument of type <mutable-pair>; given 5

> ((fn (a (b (c d (e) f)) . g) (list a b c d e f g)) 1 '(2 (3 4 (5))))
(1 2 3 4 5 nil nil)

> ((fn (a (b (c d (e) f)) . g) (list a b c d e f g)) 1 '(2 (3 4 (5) 6)))
(1 2 3 4 5 6 nil)

> ((fn (a (b (c d (e) f)) . g) (list a b c d e f g)) 1 '(2 (3 4 (5) 6)) 7)
(1 2 3 4 5 6 (7))


> ((fn (a (b (c d)) e) (list a b c d e)))
error: #<procedure>: expects 3 arguments, given 0

> ((fn (a (b (c d)) e) (list a b c d e)) 1)
error: #<procedure>: expects 3 arguments, given 1: 1

> ((fn (a (b (c d)) e) (list a b c d e)) 1 2)
error: #<procedure>: expects 3 arguments, given 2: 1 2

> ((fn (a (b (c d)) e) (list a b c d e)) 1 2 3)
error: car: expects argument of type <mutable-pair>; given 2

> ((fn (a (b (c d)) e) (list a b c d e)) 1 '(2) 3)
(1 2 nil nil 3)

> ((fn (a (b (c d)) e) (list a b c d e)) 1 '(2 3) 3)
error: car: expects argument of type <mutable-pair>; given 3

> ((fn (a (b (c d)) e) (list a b c d e)) 1 '(2 (3)) 3)
(1 2 3 nil 3)

> ((fn (a (b (c d)) e) (list a b c d e)) 1 '(2 (3 (4))) 3)
(1 2 3 (4) 3)

> ((fn (a (b (c d)) e) (list a b c d e)) 1 '(2 (3 4)) 3)
(1 2 3 4 3)

> ((fn (a (b (c d)) e) (list a b c d e)) 1 '(2 (3 4 5)) 3)
(1 2 3 4 3)

> ((fn (a (b (c d)) e) (list a b c d e)) 1 '(2 (3 4 (5))) 3)
(1 2 3 4 3)


> ((fn (a (b c d) c) (fn (a b c) (list a b c))) 1)
error: #<procedure>: expects 3 arguments, given 1: 1

> ((fn (a (b c d) c) (fn (a b c) (list a b c))) 1 2)
error: #<procedure>: expects 3 arguments, given 2: 1 2

> ((fn (a (b c d) c) (fn (a b c) (list a b c))) 1 2 3)
error: car: expects argument of type <mutable-pair>; given 2

> ((fn (a (b c d) c) (fn (a b c) (list a b c))) 1 '(2))
error: #<procedure>: expects 3 arguments, given 2: 1 {2}

> ((fn (a (b c d) c) (fn (a b c) (list a b c))) 1 '(2) 3)
#<fn>

> (((fn (a (b c d) c) (fn (a b c) (list a b c))) 1 '(2) 3) 4 5 6)
(4 5 6)


> (fn ((a) (b) (c)) (list a b c))
#<fn>

> ((fn ((a) (b) (c)) (list a b c)) 1 2)
error: #<procedure>: expects 3 arguments, given 2: 1 2

> ((fn ((a) (b) (c)) (list a b c)) 1 2 3)
error: car: expects argument of type <mutable-pair>; given 3

> ((fn ((a) (b) (c)) (list a b c)) '(1) '(2) '(3))
(1 2 3)


> ((fn (a (b) . c) (list a b c)) 1 '(2) 3)
(1 2 (3))


> (def foo (a (o b 5) (o c 10))
    (list a b c))
#<fn:foo>

> (foo 1)
(1 5 10)

> (foo 1 nil nil)
(1 nil nil)

> (foo 1 nil 3)
(1 nil 3)

> (foo 1 2 3)
(1 2 3)


;=============================================================================
;  nil
;=============================================================================

> nil
nil

> 'nil
nil


> (type nil)
sym

> (isa nil 'sym)
t


> (type 'nil)
sym

> (isa 'nil 'sym)
t


> (is nil nil)
t

> (is nil 'nil)
t

> (is 'nil nil)
t

> (is 'nil 'nil)
t


;=============================================================================
;  quasiquote
;=============================================================================

> (w/uniq qux
    `(,qux ,qux . ,qux))
(g1 g1 . g1)u


> (let name 'foo
    `',name)
(quote foo)

> (let name '(foo bar qux)
    `',@name)
(quote foo bar qux)

> (let name '(foo bar qux)
    `(+ ',@name))
(+ (quote foo bar qux))


> `(foo bar qux corge)
(foo bar qux corge)


> (with (qux    '(1 2 3 4 5)
         corge  10)
    `(foo bar ,@qux ,corge))
(foo bar 1 2 3 4 5 10)


> (with (qux    '(1 2 3 4 5)
         corge  10)
    `(foo (bar nou) ,@qux ,corge))
(foo (bar nou) 1 2 3 4 5 10)


> (with (qux    '(1 2 3 4 5)
         corge  10)
    `(foo `(bar nou) ,@qux ,corge))
(foo (#<fn:cons> (#<mac:quote> bar) (#<fn:cons> (#<mac:quote> nou) nil)) 1 2 3 4 5 10)


;=============================================================================
;  quasisyntax
;=============================================================================

> (w/uniq qux
    #`(qux qux . qux))
(g1 g1 . g1)u


> (let name 'foo
    (w/uniq (val body)
      #`(mac ,(sym "w/" name) (val . body)
          #`(parameterize (,',name val) ,@body))))
u


> #`(nil nil [push '_ nil])
(nil nil (#<mac:square-bracket> #<mac:push> _ nil))

> #`(map [uniq] (cdr nil))
(#<fn:map> (#<mac:square-bracket> #<fn:uniq>) (#<fn:cdr> nil))


> #`'+
+


> #`(+ - * /)
(#<fn:+> #<fn:-> #<fn:*> #<fn:/>)

> #`(+ - '* /)
(#<fn:+> #<fn:-> * #<fn:/>)

> #`(+ - ''* /)
(#<fn:+> #<fn:-> (quote *) #<fn:/>)


> (let body '(1 2 3)
    #`(fn ('a 'b 'c) (,@body)))
(#<mac:fn> (a b c) (1 2 3))

> (let body '(1 2 3)
    #`(fn (('o '_)) (,@body)))
(#<mac:fn> ((o _)) (1 2 3))


> (let body '((+ 1 2) (+ 2 3))
    #`(fn ('a 'b 'c) body))
(#<mac:fn> (a b c) ((+ 1 2) (+ 2 3)))

> (let body '((+ 1 2) (+ 2 3))
    #`(fn (('o '_)) body))
(#<mac:fn> ((o _)) ((+ 1 2) (+ 2 3)))


> (let body '((+ 1 2) (+ 2 3))
    #`(fn ('a 'b 'c) (,@body)))
(#<mac:fn> (a b c) ((+ 1 2) (+ 2 3)))

> (let body '((+ 1 2) (+ 2 3))
    #`(fn (('o '_)) (,@body)))
(#<mac:fn> ((o _)) ((+ 1 2) (+ 2 3)))


> (let name 'foo
    #`name)
foo

> (let name 'foo
    #`'name)
name

> (let name 'foo
    #`',name)
(#<mac:quote> foo)

> (let name '(foo bar qux)
    #`',@name)
(#<mac:quote> foo bar qux)


> (let name 'foo
    #`(+ name))
(#<fn:+> foo)

> (let name 'foo
    #`(+ 'name))
(#<fn:+> name)

> (let name 'foo
    #`(+ ',name))
(#<fn:+> (#<mac:quote> foo))

> (let name '(foo bar qux)
    #`(+ ',@name))
(#<fn:+> (#<mac:quote> foo bar qux))


> (with (qux    '(1 2 3 4 5)
         corge  10)
    #`(+ - ,@qux corge ,corge))
(#<fn:+> #<fn:-> 1 2 3 4 5 10 10)


> (with (qux    '(1 2 3 4 5)
         corge  10)
    #`(+ (- /) ,@qux corge ,corge))
(#<fn:+> (#<fn:-> #<fn:/>) 1 2 3 4 5 10 10)


> (with (qux    '(1 2 3 4 5)
         corge  10)
    #`(+ #`(- /) ,@qux corge ,corge))
(#<fn:+> (#<fn:cons> #<fn:-> (#<fn:cons> #<fn:/> nil)) 1 2 3 4 5 10 10)


;=============================================================================
;  let
;=============================================================================

> (let (a b) (list 1 2) a)
1

> (let (a b) (list 1 2) b)
2

> (let (a b) (list 1 2) c)
error: undefined variable: c


> (let (a (o b 3)) (list 1) a)
1

> (let (a (o b 3)) (list 1) b)
3


> (let (a . b) (list 1 2) a)
1

> (let (a . b) (list 1 2) b)
(2)


> (let (a) (list 1 2) a)
1


> (let (a . b) '(1 . 2)
    a)
1

> (let (a . b) '(1 . 2)
    b)
2


> (withs (foo      (list 1 2 3)
          (a . b)  foo)
    (= b.0 4)
    (is foo.1 4))
t


> (let (a (o b 5)) (list 1 2) a)
1

> (let (a (o b 5)) (list 1 2) b)
2

> (let (a (o b 5)) (list 1 nil) b)
nil


> (let (a (o b 5)) (list 1) b)
5

> (let (a (o b)) (list 1) b)
nil


> (let ((o a 5)) (list 1) a)
1

> (let ((o a 5)) (list nil) a)
nil

> (let ((o a 5)) nil a)
5


> (let (a (o b 5) c) (list 1 2) a)
1

> (let (a (o b 5) c) (list 1 2) b)
2

> (let (a (o b 5) c) (list 1 2) c)
nil

> (let (a (o b 5) c) (list 1 2 3) c)
3


;=============================================================================
;  Lists
;=============================================================================

> (list nil nil nil)
(nil nil nil)


> ('(1 2 3) -1)
error: cdr: expects argument of type <mutable-pair>; given '()

> ('(1 2 3) 0)
1

> ('(1 2 3) 1)
2

> ('(1 2 3) 2)
3

> ('(1 2 3) 3)
error: car: expects argument of type <mutable-pair>; given 3


> (scar (table) 5)
u

> (scdr (table) 10)
u


;=============================================================================
;  annotate
;=============================================================================

> (= bar '(1 2 3))
(1 2 3)

> (= foo (annotate 10 bar))

> (type foo)
10

> (rep foo)
(1 2 3)

> (is (rep foo) bar)
t


;=============================================================================
;  ssyntax
;=============================================================================


;=============================================================================
;  readline
;=============================================================================

> (fromstring "one\n\nthree\n" (drain (readline)))
("one" "\nthree")u


> (readline:instring "")
nil

> (readline:instring "\n")
"\n"

> (readline:instring "foo\n")
"foo"

> (readline:instring "foo\r\n")
"foo\r"


> (= foo (instring "foo\r\n"))
#<input-port:string>

> (readline foo)
"foo\r"

> (peekc foo)
nil


> (= foo (instring "foo\n"))
#<input-port:string>

> (readline foo)
"foo"

> (peekc foo)
nil


;=============================================================================
;  +
;=============================================================================

> (+)
0

> (+ 1)
1

> (+ 1 2)
3

> (+ 1 2 3)
6


;=============================================================================
;  Strings
;=============================================================================

> (= foo "bar")
"bar"

> (= (foo 0) #\n)
#\n

> foo
"nar"

> (import compat)
 loading:  compat.arc
nil

;=============================================================================
;  setforms
;=============================================================================

> (setforms 'foo)
(nil foo (#<mac:fn> (g1) (#<mac:assign> foo g1)))

> (setforms '(car 5))
(nil (car 5) (#<mac:fn> (g1) (#<mac:sref-mac> car g1 5)))

> (setforms '(car (car (car 5))))
((g2 (car (car 5))) (car g2) (#<mac:fn> (g1) (#<mac:sref-mac> car g1 g2)))

> (setforms '(foo 5))
(nil (foo 5) (#<mac:fn> (g1) (#<mac:sref-mac> foo g1 5)))


;=============================================================================
;  defset
;=============================================================================

> defset
u


;=============================================================================
;  fn
;=============================================================================

> (fn ())
#<fn>

> ((fn ()))
nil

> (fn (x) 5)
#<fn>

> ((fn (x) 5))
error: #<procedure>: expects 1 argument, given 0

> ((fn (x) 5) 10)
5

> ((fn (a (b) c) (list a b c)) 1)
error: #<procedure>: expects 3 arguments, given 1: 1

> ((fn (a (b) c) (list a b c)) 1 2)
error: #<procedure>: expects 3 arguments, given 2: 1 2

> ((fn (a (b) c) (list a b c)) 1 2 3)
error: car: expects argument of type <pair>; given 2

> ((fn (a (b) c) (list a b c)) 1 '(2) 3)
(1 2 3)

> ((fn (a (b) c) (list a b c)) 1 '(2 4) 3)
(1 2 3)


> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)))
error: #<case-lambda-procedure>: no clause matching 0 arguments

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1)
error: #<case-lambda-procedure>: no clause matching 1 argument: 1

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 2)
error: car: expects argument of type <pair>; given 2

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2))
(1 2 5 nil nil)

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2 3))
(1 2 5 nil nil)

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2 (3)))
(1 2 5 nil nil)

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2 (3)) nil)
(1 2 nil nil nil)

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2 (3)) nil nil)
(1 2 nil nil nil)

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2 (3)) nil nil 5 6 7)
(1 2 nil nil (5 6 7))

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2 (3)) 3)
(1 2 3 nil nil)

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2 (3)) 3 4)
(1 2 3 4 nil)

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2 (3)) 3 4 5)
(1 2 3 4 (5))

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2 (3)) 3 4 5 6)
(1 2 3 4 (5 6))

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2 (3)) 3 4 5 6 7)
(1 2 3 4 (5 6 7))


> ((fn (a (b (c d (e)))) (list a b c d e)) 1 2)
error: car: expects argument of type <pair>; given 2

> ((fn (a (b (c d (e)))) (list a b c d e)) 1 '(2))
(1 2 nil nil nil)

> ((fn (a (b (c d (e)))) (list a b c d e)) 1 '(2 3))
error: car: expects argument of type <pair>; given 3

> ((fn (a (b (c d (e)))) (list a b c d e)) 1 '(2 (3)))
(1 2 3 nil nil)

> ((fn (a (b (c d (e)))) (list a b c d e)) 1 '(2 (3 4)))
(1 2 3 4 nil)

> ((fn (a (b (c d (e)))) (list a b c d e)) 1 '(2 (3 4 5)))
error: car: expects argument of type <pair>; given 5

> ((fn (a (b (c d (e)))) (list a b c d e)) 1 '(2 (3 4 (5))))
(1 2 3 4 5)


> ((fn (a (b (c d (e) f)) . g) (list a b c d e f g)) 1 2)
error: car: expects argument of type <pair>; given 2

> ((fn (a (b (c d (e) f)) . g) (list a b c d e f g)) 1 '(2 (3 4)))
(1 2 3 4 nil nil nil)

> ((fn (a (b (c d (e) f)) . g) (list a b c d e f g)) 1 '(2 (3 4 5)))
error: car: expects argument of type <pair>; given 5

> ((fn (a (b (c d (e) f)) . g) (list a b c d e f g)) 1 '(2 (3 4 (5))))
(1 2 3 4 5 nil nil)

> ((fn (a (b (c d (e) f)) . g) (list a b c d e f g)) 1 '(2 (3 4 (5) 6)))
(1 2 3 4 5 6 nil)

> ((fn (a (b (c d (e) f)) . g) (list a b c d e f g)) 1 '(2 (3 4 (5) 6)) 7)
(1 2 3 4 5 6 (7))


> ((fn (a (b (c d)) e) (list a b c d e)))
error: #<procedure>: expects 3 arguments, given 0

> ((fn (a (b (c d)) e) (list a b c d e)) 1)
error: #<procedure>: expects 3 arguments, given 1: 1

> ((fn (a (b (c d)) e) (list a b c d e)) 1 2)
error: #<procedure>: expects 3 arguments, given 2: 1 2

> ((fn (a (b (c d)) e) (list a b c d e)) 1 2 3)
error: car: expects argument of type <pair>; given 2

> ((fn (a (b (c d)) e) (list a b c d e)) 1 '(2) 3)
(1 2 nil nil 3)

> ((fn (a (b (c d)) e) (list a b c d e)) 1 '(2 3) 3)
error: car: expects argument of type <pair>; given 3

> ((fn (a (b (c d)) e) (list a b c d e)) 1 '(2 (3)) 3)
(1 2 3 nil 3)

> ((fn (a (b (c d)) e) (list a b c d e)) 1 '(2 (3 (4))) 3)
(1 2 3 (4) 3)

> ((fn (a (b (c d)) e) (list a b c d e)) 1 '(2 (3 4)) 3)
(1 2 3 4 3)

> ((fn (a (b (c d)) e) (list a b c d e)) 1 '(2 (3 4 5)) 3)
(1 2 3 4 3)

> ((fn (a (b (c d)) e) (list a b c d e)) 1 '(2 (3 4 (5))) 3)
(1 2 3 4 3)


> ((fn (a (b c d) c) (fn (a b c) (list a b c))) 1)
error: #<procedure>: expects 3 arguments, given 1: 1

> ((fn (a (b c d) c) (fn (a b c) (list a b c))) 1 2)
error: #<procedure>: expects 3 arguments, given 2: 1 2

> ((fn (a (b c d) c) (fn (a b c) (list a b c))) 1 2 3)
error: car: expects argument of type <pair>; given 2

> ((fn (a (b c d) c) (fn (a b c) (list a b c))) 1 '(2))
error: #<procedure>: expects 3 arguments, given 2: 1 '(2)

> ((fn (a (b c d) c) (fn (a b c) (list a b c))) 1 '(2) 3)
#<fn>

> (((fn (a (b c d) c) (fn (a b c) (list a b c))) 1 '(2) 3) 4 5 6)
(4 5 6)


> (fn ((a) (b) (c)) (list a b c))
#<fn>

> ((fn ((a) (b) (c)) (list a b c)) 1 2)
error: #<procedure>: expects 3 arguments, given 2: 1 2

> ((fn ((a) (b) (c)) (list a b c)) 1 2 3)
error: car: expects argument of type <pair>; given 3

> ((fn ((a) (b) (c)) (list a b c)) '(1) '(2) '(3))
(1 2 3)


> ((fn (a (b) . c) (list a b c)) 1 '(2) 3)
(1 2 (3))


> (def foo (a (o b 5) (o c 10))
    (list a b c))
#<fn:foo>

> (foo 1)
(1 5 10)

> (foo 1 nil nil)
(1 nil nil)

> (foo 1 nil 3)
(1 nil 3)

> (foo 1 2 3)
(1 2 3)


;=============================================================================
;  nil
;=============================================================================

> nil
nil

> 'nil
nil


> (type nil)
sym

> (isa nil 'sym)
t


> (type 'nil)
sym

> (isa 'nil 'sym)
t


> (is nil nil)
t

> (is nil 'nil)
t

> (is 'nil nil)
t

> (is 'nil 'nil)
t


;=============================================================================
;  quasiquote
;=============================================================================

> (w/uniq qux
    `(,qux ,qux . ,qux))
(g1 g1 . g1)


> (let name 'foo
    `',name)
(quote foo)

> (let name '(foo bar qux)
    `',@name)
(quote foo bar qux)

> (let name '(foo bar qux)
    `(+ ',@name))
(+ (quote foo bar qux))


> `(foo bar qux corge)
(foo bar qux corge)


> (with (qux    '(1 2 3 4 5)
         corge  10)
    `(foo bar ,@qux ,corge))
(foo bar 1 2 3 4 5 10)


> (with (qux    '(1 2 3 4 5)
         corge  10)
    `(foo (bar nou) ,@qux ,corge))
(foo (bar nou) 1 2 3 4 5 10)


> (with (qux    '(1 2 3 4 5)
         corge  10)
    `(foo `(bar nou) ,@qux ,corge))
(foo (#<fn:cons> (#<mac:quote> bar) (#<fn:cons> (#<mac:quote> nou) nil)) 1 2 3 4 5 10)


;=============================================================================
;  quasisyntax
;=============================================================================

> (w/uniq qux
    #`(qux qux . qux))
(g1 g1 . g1)


> (let name 'foo
    (w/uniq (val body)
      #`(mac ,(sym "w/" name) (val . body)
          #`(parameterize (,',name val) ,@body))))
(#<mac:mac> w/foo (g1 . g2) (#<fn:cons> #<mac:parameterize> (#<fn:cons> (#<fn:cons> (#<mac:quote> foo) (#<fn:cons> g1 nil)) g2)))


> #`(nil nil [push '_ nil])
(nil nil (#<mac:square-bracket> #<mac:push> _ nil))

> #`(map [uniq] (cdr nil))
(#<fn:map> (#<mac:square-bracket> #<fn:uniq>) (#<fn:cdr> nil))


> #`'+
+


> #`(+ - * /)
(#<fn:+> #<fn:-> #<fn:*> #<fn:/>)

> #`(+ - '* /)
(#<fn:+> #<fn:-> * #<fn:/>)

> #`(+ - ''* /)
(#<fn:+> #<fn:-> (#<mac:quote> *) #<fn:/>)


> (let body '(1 2 3)
    #`(fn ('a 'b 'c) (,@body)))
(#<mac:fn> (a b c) (1 2 3))

> (let body '(1 2 3)
    #`(fn (('o '_)) (,@body)))
(#<mac:fn> ((o _)) (1 2 3))


> (let body '((+ 1 2) (+ 2 3))
    #`(fn ('a 'b 'c) body))
(#<mac:fn> (a b c) ((+ 1 2) (+ 2 3)))

> (let body '((+ 1 2) (+ 2 3))
    #`(fn (('o '_)) body))
(#<mac:fn> ((o _)) ((+ 1 2) (+ 2 3)))


> (let body '((+ 1 2) (+ 2 3))
    #`(fn ('a 'b 'c) (,@body)))
(#<mac:fn> (a b c) ((+ 1 2) (+ 2 3)))

> (let body '((+ 1 2) (+ 2 3))
    #`(fn (('o '_)) (,@body)))
(#<mac:fn> ((o _)) ((+ 1 2) (+ 2 3)))


> (let name 'foo
    #`name)
foo

> (let name 'foo
    #`'name)
name

> (let name 'foo
    #`',name)
(#<mac:quote> foo)

> (let name '(foo bar qux)
    #`',@name)
(#<mac:quote> foo bar qux)


> (let name 'foo
    #`(+ name))
(#<fn:+> foo)

> (let name 'foo
    #`(+ 'name))
(#<fn:+> name)

> (let name 'foo
    #`(+ ',name))
(#<fn:+> (#<mac:quote> foo))

> (let name '(foo bar qux)
    #`(+ ',@name))
(#<fn:+> (#<mac:quote> foo bar qux))


> (with (qux    '(1 2 3 4 5)
         corge  10)
    #`(+ - ,@qux corge ,corge))
(#<fn:+> #<fn:-> 1 2 3 4 5 10 10)


> (with (qux    '(1 2 3 4 5)
         corge  10)
    #`(+ (- /) ,@qux corge ,corge))
(#<fn:+> (#<fn:-> #<fn:/>) 1 2 3 4 5 10 10)


> (with (qux    '(1 2 3 4 5)
         corge  10)
    #`(+ #`(- /) ,@qux corge ,corge))
(#<fn:+> (#<fn:cons> #<fn:-> (#<fn:cons> #<fn:/> nil)) 1 2 3 4 5 10 10)


;=============================================================================
;  let
;=============================================================================

> (let (a b) (list 1 2) a)
1

> (let (a b) (list 1 2) b)
2

> (let (a b) (list 1 2) c)
error: undefined variable: c


> (let (a (o b 3)) (list 1) a)
1

> (let (a (o b 3)) (list 1) b)
3


> (let (a . b) (list 1 2) a)
1

> (let (a . b) (list 1 2) b)
(2)


> (let (a) (list 1 2) a)
1


> (let (a . b) '(1 . 2)
    a)
1

> (let (a . b) '(1 . 2)
    b)
2


> (withs (foo      (list 1 2 3)
          (a . b)  foo)
    (= b.0 4)
    (is foo.1 4))
t


> (let (a (o b 5)) (list 1 2) a)
1

> (let (a (o b 5)) (list 1 2) b)
2

> (let (a (o b 5)) (list 1 nil) b)
nil


> (let (a (o b 5)) (list 1) b)
5

> (let (a (o b)) (list 1) b)
nil


> (let ((o a 5)) (list 1) a)
1

> (let ((o a 5)) (list nil) a)
nil

> (let ((o a 5)) nil a)
5


> (let (a (o b 5) c) (list 1 2) a)
1

> (let (a (o b 5) c) (list 1 2) b)
2

> (let (a (o b 5) c) (list 1 2) c)
nil

> (let (a (o b 5) c) (list 1 2 3) c)
3


;=============================================================================
;  Lists
;=============================================================================

> (list nil nil nil)
(nil nil nil)


> ('(1 2 3) -1)
error: list-ref: expects type <non-negative exact integer> as 2nd argument, given: -1; other arguments were: '(1 2 3)

> ('(1 2 3) 0)
1

> ('(1 2 3) 1)
2

> ('(1 2 3) 2)
3

> ('(1 2 3) 3)
error: list-ref: index 3 too large for list: '(1 2 3)


> (scar (obj) 5)
error: scar: expected argument of type <pair>; given '#hash()

> (scdr (obj) 10)
error: scdr: expected argument of type <pair>; given '#hash()


;=============================================================================
;  annotate
;=============================================================================

> (= bar '(1 2 3))
(1 2 3)

> (= foo (annotate 10 bar))

> (type foo)
10

> (rep foo)
(1 2 3)

> (is (rep foo) bar)
t


;=============================================================================
;  ssyntax
;=============================================================================


;=============================================================================
;  readline
;=============================================================================

> (fromstring "one\n\nthree\n" (drain (readline)))
("one" "\nthree")


> (readline:instring "")
nil

> (readline:instring "foo")
"foo"

> (readline:instring "\n")
"\n"

> (readline:instring "foo\n")
"foo"

> (readline:instring "foo\r\n")
"foo\r"


> (= foo (instring "foo\r\n"))
#<input-port:string>

> (readline foo)
"foo\r"

> (peekc foo)
nil


> (= foo (instring "foo\n"))
#<input-port:string>

> (readline foo)
"foo"

> (peekc foo)
nil


;=============================================================================
;  +
;=============================================================================

> (+)
0

> (+ 1)
1

> (+ 1 2)
3

> (+ 1 2 3)
6


;=============================================================================
;  assoc
;=============================================================================

> (assoc 'a '((b 10) (a 5)))
(a 5)

> (assoc 'b '((b 10) (a 5)))
(b 10)

> (assoc 'c '((b 10) (a 5)))
nil


;=============================================================================
;  Strings
;=============================================================================

> (= foo "bar")
"bar"

> (= (foo 0) #\n)
#\n

> foo
"nar"


;=============================================================================
;  coerce
;=============================================================================

> (coerce #\a 'string)
"a"

> (coerce #\a 'int)
97

> (coerce #\a 'sym)
a

> (coerce #\a 'nou)
error: can't coerce #\a nou


> (coerce '((a 2) (b 4)) 'table)
#hash((a . 2) (b . 4))

> (coerce '((a 2) (b 4)) 'string)
"a2b4"

> (coerce '((a 2) (b 4)) 'nou)
error: can't coerce ((a 2) (b 4)) nou


> (coerce 10 'string)
"10"

> (coerce 10 'char)
#\newline

> (coerce 10 'num)
10.0

> (coerce 10 'nou)
error: can't coerce 10 nou


> (coerce '#:foo 'string)
"foo"

> (coerce '#:foo 'sym)
foo

> (coerce '#:foo 'nou)
error: can't coerce #:foo nou


> (coerce nil 'cons)
nil

> (coerce nil 'string)
""

> (coerce nil 'table)
#hash()

> (coerce nil 'nou)
error: can't coerce () nou


> (coerce 10.5 'string)
"10.5"

> (coerce 10.5 'char)
#\newline

> (coerce 10.5 'int)
10

> (coerce 10.5 'nou)
error: can't coerce 10.5 nou


> (coerce "foo" 'keyword)
#:foo

> (coerce "foo" 'cons)
(#\f #\o #\o)

> (coerce "foo" 'sym)
foo

> (coerce "foo" 'int)
error: can't coerce "foo" int

> (coerce "10.5" 'int)
10

> (coerce "10.5" 'int 16)
16

> (coerce "10.5" 'int 17)
error: string->number: expects type <exact integer in [2, 16]> as 2nd argument, given: 17; other arguments were: "10.5"

> (coerce "foo" 'num)
error: can't coerce "foo" num

> (coerce "10.5" 'num)
10.5

> (coerce "10.5" 'num 16)
16.3125

> (coerce "10.5" 'num 17)
error: string->number: expects type <exact integer in [2, 16]> as 2nd argument, given: 17; other arguments were: "10.5"

> (coerce "foo" 'nou)
error: can't coerce "foo" nou


> (coerce 'foo 'string)
"foo"

> (coerce 'foo 'nou)
error: can't coerce foo nou


> (coerce (obj a 1 b 2) 'cons)
((a 1) (b 2))

> (coerce (obj a 1 b 2) 'nou)
error: can't coerce #hash((b . 2) (a . 1)) nou

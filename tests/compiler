> (= namespace arc3-namespace)
#<namespace:0>

;=============================================================================
;  Compiler specific things
;=============================================================================

> (car (cadr (ac-compile ''(1 2 3))))
(1 2 3)

> (ac-compile ''foo)
#<quoted>


> (racket-parameterize ((racket-current-namespace (racket-current-namespace)))
    (racket-current-namespace))
error: racket-parameterize: bad syntax in: racket-parameterize


;=============================================================================
;  do / with / withs / or optimizations
;=============================================================================

> (ac-compile '(do 1))
1

> (ac-compile '(do 1 2))
((racket-lambda nil 1 2))



> (ac-compile '(with () 1))
1

> (ac-compile '(with () 1 2))
((racket-lambda nil 1 2))


;; TODO: not sure about this
> (ac-compile '(with nil 1))
error: cdr: expects argument of type <pair>; given 'nil

> (ac-compile '(with nil 1 2))
error: cdr: expects argument of type <pair>; given 'nil


> (ac-compile '(with (a 5) 1))
((racket-lambda (a) 1) 5)

> (ac-compile '(with (a 5) 1 2))
((racket-lambda (a) 1 2) 5)



> (ac-compile '(withs () 1))
1

> (ac-compile '(withs () 1 2))
((racket-lambda nil 1 2))


;; TODO: not sure about this
> (ac-compile '(withs nil 1))
error: car: expects argument of type <pair>; given 'nil

> (ac-compile '(withs nil 1 2))
error: car: expects argument of type <pair>; given 'nil


> (ac-compile '(withs (a 5) 1))
((racket-lambda (a) 1) 5)

> (ac-compile '(withs (a 5) 1 2))
((racket-lambda (a) ((racket-lambda nil 1 2))) 5)



> (ac-compile '(or))
nil

> (ac-compile '(or a))
(#<fn:ac-lookup-global-arg> a)

> (ac-compile '(or a b))
((racket-lambda (g1) (racket-if (#<fn:ac-true> g1) g1 (#<fn:ac-lookup-global-arg> b))) (#<fn:ac-lookup-global-arg> a))

> (ac-compile '(or a b c))
((racket-lambda (g1) (racket-if (#<fn:ac-true> g1) g1 ((racket-lambda (g2) (racket-if (#<fn:ac-true> g2) g2 (#<fn:ac-lookup-global-arg> c))) (#<fn:ac-lookup-global-arg> b)))) (#<fn:ac-lookup-global-arg> a))

> (ac-compile '(or a b c d))
((racket-lambda (g1) (racket-if (#<fn:ac-true> g1) g1 ((racket-lambda (g2) (racket-if (#<fn:ac-true> g2) g2 ((racket-lambda (g3) (racket-if (#<fn:ac-true> g3) g3 (#<fn:ac-lookup-global-arg> d))) (#<fn:ac-lookup-global-arg> c)))) (#<fn:ac-lookup-global-arg> b)))) (#<fn:ac-lookup-global-arg> a))


;=============================================================================
;  Assignment
;=============================================================================

> (ac-compile '(assign foo 10))
(#<fn:ac-assign-global-raw> #<namespace:0> (racket-quote foo) 10)

> (ac-compile '(assign foo 10 bar 20 qux 30))
(racket-begin (#<fn:ac-assign-global-raw> #<namespace:0> (racket-quote foo) 10) (#<fn:ac-assign-global-raw> #<namespace:0> (racket-quote bar) 20) (#<fn:ac-assign-global-raw> #<namespace:0> (racket-quote qux) 30))


> (ac-compile '(let foo 10 (assign foo 20)))
((racket-lambda (foo) (racket-begin (racket-set! foo 20) foo)) 10)

> (ac-compile '(let foo 10 (assign foo)))
((racket-lambda (foo) (racket-begin (racket-set! foo nil) foo)) 10)


> (ac-compile '(with (foo  10
                      bar  20
                      qux  30)
                 (assign foo 20 bar 30 qux 40)))
((racket-lambda (foo bar qux) (racket-begin (racket-set! foo 20) (racket-set! bar 30) (racket-set! qux 40) qux)) 10 20 30)


> (ac-compile '(with (foo  10
                      bar  20
                      qux  30)
                 (assign foo 20 bar 30 qux)))
((racket-lambda (foo bar qux) (racket-begin (racket-set! foo 20) (racket-set! bar 30) (racket-set! qux nil) qux)) 10 20 30)


> (ac-compile '(with (foo  10
                      bar  20
                      qux  30)
                 (assign nou 20 bar 30 qux 40)))
((racket-lambda (foo bar qux) (racket-begin (#<fn:ac-assign-global-raw> #<namespace:0> (racket-quote nou) 20) (racket-set! bar 30) (racket-set! qux 40) qux)) 10 20 30)


> (ac-compile '(with (foo  10
                      bar  20
                      qux  30)
                 (assign nou 20 bar 30 cooorge 40)))
((racket-lambda (foo bar qux) (racket-begin (#<fn:ac-assign-global-raw> #<namespace:0> (racket-quote nou) 20) (racket-set! bar 30) (#<fn:ac-assign-global-raw> #<namespace:0> (racket-quote cooorge) 40))) 10 20 30)


;=============================================================================
;  compose and complement optimizations
;=============================================================================

> (ac-compile '(foo:bar 1))
(#<fn:ac-funcall1> (#<fn:ac-lookup-global> foo) (#<fn:ac-funcall1> (#<fn:ac-lookup-global> bar) 1))

> (ac-compile '(foo:bar:qux 1))
(#<fn:ac-funcall1> (#<fn:ac-lookup-global> foo) (#<fn:ac-funcall1> (#<fn:ac-lookup-global> bar) (#<fn:ac-funcall1> (#<fn:ac-lookup-global> qux) 1)))

> (ac-compile '(~foo 1))
(#<fn:ac-funcall1> (#<fn:ac-lookup-global> no) (#<fn:ac-funcall1> (#<fn:ac-lookup-global> foo) 1))

> (ac-compile '(~foo:bar 1))
(#<fn:ac-funcall1> (#<fn:ac-lookup-global> no) (#<fn:ac-funcall1> (#<fn:ac-lookup-global> foo) (#<fn:ac-funcall1> (#<fn:ac-lookup-global> bar) 1)))

> (ac-compile '(foo:~bar 1))
(#<fn:ac-funcall1> (#<fn:ac-lookup-global> foo) (#<fn:ac-funcall1> (#<fn:ac-lookup-global> no) (#<fn:ac-funcall1> (#<fn:ac-lookup-global> bar) 1)))


;=============================================================================
;  fn
;=============================================================================

> (ac-compile '(fn args args))
(racket-lambda args args)


> (ac-compile '(fn (a b c) (list a b c)))
(racket-lambda (a b c) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))


> (ac-compile '(fn (a (o b 5) c) (list a b c)))
(racket-lambda (a (b 5) c) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))

> (fn (a (o b 5) c) (list a b c))
error: racket-lambda: default-value expression missing at: c in: (racket-lambda (a (b 5) c) (#<procedure:ac-funcall3> (#<procedure:ac-lookup-global> list) a b c))


> (ac-compile '(fn (a b (o c 5)) (list a b c)))
(racket-lambda (a b (c 5)) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))

> (ac-compile '(fn (a b (o c nil)) (list a b c)))
(racket-lambda (a b (c (#<fn:ac-lookup-global-arg> nil))) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))

> (ac-compile '(fn (a b (o c)) (list a b c)))
(racket-lambda (a b (c nil)) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))


> (ac-compile '(fn (a b . c) (list a b c)))
(racket-lambda (a b . c) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))


> (ac-compile '(fn (a b (c (d e f (g)))) (list a b c d e f g)))
(racket-lambda (a b g1) (racket-let* ((c (#<fn:car> g1)) (g1 (#<fn:cdr> g1)) (g2 (#<fn:car> g1)) (d (#<fn:car> g2)) (g2 (#<fn:cdr> g2)) (e (#<fn:car> g2)) (g2 (#<fn:cdr> g2)) (f (#<fn:car> g2)) (g2 (#<fn:cdr> g2)) (g3 (#<fn:car> g2)) (g (#<fn:car> g3))) (#<fn:ac-apply> (#<fn:ac-lookup-global> list) a b c d e f g)))


> (ac-compile '(fn (a (b) c) (fn (a b c) (list a b c))))
(racket-lambda (a g1 c) (racket-let* ((b (#<fn:car> g1))) (racket-lambda (a b c) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))))

> (ac-compile '(fn (a (b) c) (fn (a b (c)) (fn (a b c) (list a b c)))))
(racket-lambda (a g1 c) (racket-let* ((b (#<fn:car> g1))) (racket-lambda (a b g2) (racket-let* ((c (#<fn:car> g2))) (racket-lambda (a b c) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))))))

> (parameterize (ac-fn-required-args? #f
                 ac-fn-excess-args?   #t)
    (ac-compile '(fn (a (b) c) (fn (a b c) (list a b c)))))
(racket-lambda ((a nil) (g1 nil) (c nil) . g2) (racket-let* ((b (#<fn:car> g1))) (racket-lambda ((a nil) (b nil) (c nil) . g3) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))))

> (parameterize (ac-fn-required-args?       #f
                 ac-fn-excess-args?         #t
                 ac-fn-rigid-destructuring? #t)
    (ac-compile '(fn (a (b) c) (fn (a b c) (list a b c)))))
(racket-lambda ((a nil) (g1 nil) (c nil) . g2) (racket-let* ((b (racket-car g1)) (g1 (racket-cdr g1))) (racket-lambda ((a nil) (b nil) (c nil) . g3) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))))


> (ac-compile '(fn (a (b (c d (o e 10) (f) . g)) #:foo (o z 5) (o #:bar 15) . h) ac-local-env*)
(a b c d e f g foo z bar h)


> (ac-compile '((fn ((o a a)) a)))
((racket-lambda ((a (#<fn:ac-lookup-global-arg> a))) a))

(ac-compile '((fn ((o a (#<fn:ac-lookup-global a))) a)) nil)


> (ac-compile '(fn (a b c) (list a b c)))
(racket-lambda (a b c) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))

> (ac-compile '(fn (a b (o c 5)) (list a b c)))
(racket-lambda (a b (c 5)) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))

> (ac-compile '(fn (a (b) (o c 5)) (list a b c)))
(racket-lambda (a g1 (c 5)) (racket-let* ((b (#<fn:car> g1))) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c)))

> (ac-compile '(fn (a (b (c d)) (o c 5)) (list a b c d)))
(racket-lambda (a g1 (c 5)) (racket-let* ((b (#<fn:car> g1)) (g1 (#<fn:cdr> g1)) (g2 (#<fn:car> g1)) (c (#<fn:car> g2)) (g2 (#<fn:cdr> g2)) (d (#<fn:car> g2))) (#<fn:ac-funcall4> (#<fn:ac-lookup-global> list) a b c d)))

> (ac-compile '(fn (a (b (c d . e)) (o c 5) . f) (list a b c d e f)))
(racket-lambda (a g1 (c 5) . f) (racket-let* ((b (#<fn:car> g1)) (g1 (#<fn:cdr> g1)) (g2 (#<fn:car> g1)) (c (#<fn:car> g2)) (g2 (#<fn:cdr> g2)) (d (#<fn:car> g2)) (g2 (#<fn:cdr> g2)) (e g2)) (#<fn:ac-apply> (#<fn:ac-lookup-global> list) a b c d e f)))

> (ac-compile '(fn (a (b (c (o d 10) . e)) (o c 5) . f) (list a b c d e f)))
(racket-lambda (a g1 (c 5) . f) (racket-let* ((b (#<fn:car> g1)) (g1 (#<fn:cdr> g1)) (g2 (#<fn:car> g1)) (c (#<fn:car> g2)) (g2 (#<fn:cdr> g2)) (d (racket-if (#<fn:ac-true> (#<fn:cdr> g2)) (#<fn:car> g2) 10)) (g2 (#<fn:cdr> g2)) (e g2)) (#<fn:ac-apply> (#<fn:ac-lookup-global> list) a b c d e f)))

> (ac-compile '(fn (a (b (c (o d 10) . e)) :foo (o c 5) . f) (list a b c d e f foo)))
(racket-lambda (a g1 #:foo (foo nil) (c 5) . f) (racket-let* ((b (#<fn:car> g1)) (g1 (#<fn:cdr> g1)) (g2 (#<fn:car> g1)) (c (#<fn:car> g2)) (g2 (#<fn:cdr> g2)) (d (racket-if (#<fn:ac-true> (#<fn:cdr> g2)) (#<fn:car> g2) 10)) (g2 (#<fn:cdr> g2)) (e g2)) (#<fn:ac-apply> (#<fn:ac-lookup-global> list) a b c d e f foo)))

> (ac-compile '(fn (a (b (c (o d 10) . e)) (o :foo 15) (o c 5) . f) (list a b c d e f foo)))
(racket-lambda (a g1 #:foo (foo 15) (c 5) . f) (racket-let* ((b (#<fn:car> g1)) (g1 (#<fn:cdr> g1)) (g2 (#<fn:car> g1)) (c (#<fn:car> g2)) (g2 (#<fn:cdr> g2)) (d (racket-if (#<fn:ac-true> (#<fn:cdr> g2)) (#<fn:car> g2) 10)) (g2 (#<fn:cdr> g2)) (e g2)) (#<fn:ac-apply> (#<fn:ac-lookup-global> list) a b c d e f foo)))


> (ac-compile '(fn (a) (fn (b) (list a b c))))
(racket-lambda (a) (racket-lambda (b) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b (#<fn:ac-lookup-global-arg> c))))

> (ac-compile '(fn a a))
(racket-lambda a a)

> (ac-compile '(fn (a) a))
(racket-lambda (a) a)

> (ac-compile '(fn (:a) a))
(racket-lambda (#:a (a nil)) a)

> (ac-compile '(fn ((o a 5)) a))
(racket-lambda ((a 5)) a)

> (ac-compile '(fn ((o :a 5)) a))
(racket-lambda (#:a (a 5)) a)

> (ac-compile '(fn (a . b) (list a b)))
(racket-lambda (a . b) (#<fn:ac-funcall2> (#<fn:ac-lookup-global> list) a b))

> (ac-compile '(fn ((a)) a))
(racket-lambda (g1) (racket-let* ((a (#<fn:car> g1))) a))

> (ac-compile '(fn ((a (o b 5))) (list a b)))
(racket-lambda (g1) (racket-let* ((a (#<fn:car> g1)) (g1 (#<fn:cdr> g1)) (b (racket-if (#<fn:ac-true> (#<fn:cdr> g1)) (#<fn:car> g1) 5))) (#<fn:ac-funcall2> (#<fn:ac-lookup-global> list) a b)))

> (ac-compile '(fn ((a . b)) (list a b)))
(racket-lambda (g1) (racket-let* ((a (#<fn:car> g1)) (g1 (#<fn:cdr> g1)) (b g1)) (#<fn:ac-funcall2> (#<fn:ac-lookup-global> list) a b)))


;=============================================================================
;  Function calls
;=============================================================================

> (ac-compile '(foo))
(#<fn:ac-funcall0> (#<fn:ac-lookup-global> foo))

> (ac-compile '(foo 1))
(#<fn:ac-funcall1> (#<fn:ac-lookup-global> foo) 1)

> (ac-compile '(foo 1 2))
(#<fn:ac-funcall2> (#<fn:ac-lookup-global> foo) 1 2)

> (ac-compile '(foo 1 2 3))
(#<fn:ac-funcall3> (#<fn:ac-lookup-global> foo) 1 2 3)

> (ac-compile '(foo 1 2 3 4))
(#<fn:ac-funcall4> (#<fn:ac-lookup-global> foo) 1 2 3 4)

> (ac-compile '(foo 1 2 3 4 5))
(#<fn:ac-apply> (#<fn:ac-lookup-global> foo) 1 2 3 4 5)

> (ac-compile '(foo :a 1))
(#<fn:ac-apply> (#<fn:ac-lookup-global> foo) #:a 1)


;=============================================================================
;  Function names
;=============================================================================

> ac-apply
#<fn:ac-apply>

> apply
#<fn:apply>

> is
#<fn:is>

> +
#<fn:+>

> <
#<fn:<>

> >
#<fn:>>

> ac-apply-non-fn
#<fn:ac-apply-non-fn>

> ac-assign-global-raw
#<fn:ac-assign-global-raw>

> bound
#<fn:bound>

> cons
#<fn:cons>

> list
#<fn:list>

> sref
#<fn:sref>

> ac-tnil
#<fn:ac-tnil>


;=============================================================================
;  sig
;=============================================================================

> (sig 'namespace-get)
(runtime varname (o default))

> (type (sig 'namespace-get))
cons

> (type (car (cddr (sig 'namespace-get))))
cons


> (sig 'uniq)
((o name (quote g)) (o num))

> (type (sig 'uniq))
cons

> (type (car (sig 'uniq)))
cons


> (sig 'ac-var)
(x (o def))

> (type (sig 'ac-var))
cons

> (type (cadr (sig 'ac-var)))
cons


> (sig 'bound)
(name)

> (type (sig 'bound))
cons


> (sig 'err)
(x . rest)

> (type (sig 'err))
cons


> (sig 'cons)
(x y)

> (type (sig 'cons))
cons


> (sig 'list)
args

> (type (sig 'list))
sym


> (sig 'ac-apply-non-fn)
(x (o k) (o d))

> (type (sig 'ac-apply-non-fn))
cons

> (type (cadr (sig 'ac-apply-non-fn)))
cons


> (sig 'ac-apply)
(f . racket-arg-list)

> (type (sig 'ac-apply))
cons


> (sig 'apply)
(f . args)

> (type (sig 'apply))
cons


> (sig 'ac-assign-global-raw)
(space a b)

> (type (sig 'ac-assign-global-raw))
cons


> (sig 'sref)
(f val key (o ind))

> (type (sig 'sref))
cons

> (type (cadr (cddr (sig 'sref))))
cons


> (sig 'is)
args

> (type (sig 'is))
sym


> (sig 'eval)
(x (o runtime))

> (type (sig 'eval))
cons

> (type (cadr (sig 'eval)))
cons


;=============================================================================


> (sig 'ac-tnil)
(x)

> (type (sig 'ac-tnil))
cons


> (sig 'assign)
args

> (type (sig 'assign))
sym


> (sig 'fn)
(parms . body)

> (type (sig 'fn))
cons


> (sig 'ac-compile)
(x)

> (type (sig 'ac-compile))
cons


> (sig 'do)
args

> (type (sig 'do))
sym


> (sig 'isa)
(x y)

> (type (sig 'isa))
cons


;=============================================================================
;  Macros
;=============================================================================

> (mac macfoo (x) (+ 1 2) (+ 1 2))
#<mac:macfoo>

> (macfoo)
error: #<procedure>: expects 1 argument, given 0

> (macfoo 5)
3


;=============================================================================
;  ssyntax
;=============================================================================

> (expand-full '(~foo:bar:qux (~~bar bar:qux 5)))
(no (foo (bar (qux (no (no (bar (#<mac:compose> bar qux) 5)))))))


;=============================================================================
;  annotate
;=============================================================================

> annotate
#<fn:annotate>

> (annotate '(1 2 3) '(4 5 6))
#(tagged (1 2 3) (4 5 6))

> (annotate + -)
#(tagged #<fn:+> #<fn:->)

> assign
#<mac:assign>

> fn
#<mac:fn>

> if
#<mac:if>

> quote
#<mac:quote>

> quasiquote
#<mac:quasiquote>

> quasisyntax
#<mac:quasisyntax>

> %nocompile
#<mac:%nocompile>

> %splice
#<mac:%splice>

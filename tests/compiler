> (namespace arc3-namespace)
#<namespace:0>

;=============================================================================
;  Compiler specific things
;=============================================================================

> ((car (ac-compile ''(1 2 3))))
(1 2 3)

> (ac-compile ''foo)
#<quoted>


> (racket-parameterize ((racket-current-namespace (racket-current-namespace)))
    (racket-current-namespace))
error: racket-parameterize: bad syntax in: racket-parameterize


;=============================================================================
;  do / with / withs optimizations
;=============================================================================

> (ac-compile '(do 1))
1

> (ac-compile '(do 1 2))
((racket-lambda nil 1 2))



> (ac-compile '(with () 1))
1

> (ac-compile '(with () 1 2))
((racket-lambda nil 1 2))


;; TODO: not sure about this
> (ac-compile '(with nil 1))
error: mcdr: expects argument of type <mutable-pair>; given 'nil

> (ac-compile '(with nil 1 2))
error: mcdr: expects argument of type <mutable-pair>; given 'nil


> (ac-compile '(with (a 5) 1))
((racket-lambda (a) 1) 5)

> (ac-compile '(with (a 5) 1 2))
((racket-lambda (a) 1 2) 5)



> (ac-compile '(withs () 1))
1

> (ac-compile '(withs () 1 2))
((racket-lambda nil 1 2))


;; TODO: not sure about this
> (ac-compile '(withs nil 1))
error: mcar: expects argument of type <mutable-pair>; given 'nil

> (ac-compile '(withs nil 1 2))
error: mcar: expects argument of type <mutable-pair>; given 'nil


> (ac-compile '(withs (a 5) 1))
((racket-lambda (a) 1) 5)

> (ac-compile '(withs (a 5) 1 2))
((racket-lambda (a) ((racket-lambda nil 1 2))) 5)


;=============================================================================
;  Assignment
;=============================================================================

> (ac-compile '(assign foo 10))
(#<fn:ac-global-assign-raw> (racket-quote foo) 10)

> (ac-compile '(assign foo 10 bar 20 qux 30))
(racket-begin (#<fn:ac-global-assign-raw> (racket-quote foo) 10) (#<fn:ac-global-assign-raw> (racket-quote bar) 20) (#<fn:ac-global-assign-raw> (racket-quote qux) 30))


> (ac-compile '(let foo 10 (assign foo 20)))
((racket-lambda (foo) (racket-begin (racket-set! foo 20) foo)) 10)

> (ac-compile '(let foo 10 (assign foo)))
((racket-lambda (foo) (racket-begin (racket-set! foo nil) foo)) 10)


> (ac-compile '(with (foo  10
                      bar  20
                      qux  30)
                 (assign foo 20 bar 30 qux 40)))
((racket-lambda (foo bar qux) (racket-begin (racket-set! foo 20) (racket-set! bar 30) (racket-set! qux 40) qux)) 10 20 30)


> (ac-compile '(with (foo  10
                      bar  20
                      qux  30)
                 (assign foo 20 bar 30 qux)))
((racket-lambda (foo bar qux) (racket-begin (racket-set! foo 20) (racket-set! bar 30) (racket-set! qux nil) qux)) 10 20 30)


> (ac-compile '(with (foo  10
                      bar  20
                      qux  30)
                 (assign nou 20 bar 30 qux 40)))
((racket-lambda (foo bar qux) (racket-begin (#<fn:ac-global-assign-raw> (racket-quote nou) 20) (racket-set! bar 30) (racket-set! qux 40) qux)) 10 20 30)


> (ac-compile '(with (foo  10
                      bar  20
                      qux  30)
                 (assign nou 20 bar 30 cooorge 40)))
((racket-lambda (foo bar qux) (racket-begin (#<fn:ac-global-assign-raw> (racket-quote nou) 20) (racket-set! bar 30) (#<fn:ac-global-assign-raw> (racket-quote cooorge) 40))) 10 20 30)


;=============================================================================
;  compose and complement optimizations
;=============================================================================

> (ac-compile '(foo:bar 1))
(#<fn:ac-funcall1> (#<fn:ac-lookup-global> foo) (#<fn:ac-funcall1> (#<fn:ac-lookup-global> bar) 1))

> (ac-compile '(foo:bar:qux 1))
(#<fn:ac-funcall1> (#<fn:ac-lookup-global> foo) (#<fn:ac-funcall1> (#<fn:ac-lookup-global> bar) (#<fn:ac-funcall1> (#<fn:ac-lookup-global> qux) 1)))

> (ac-compile '(~foo 1))
(#<fn:ac-funcall1> (#<fn:ac-lookup-global> no) (#<fn:ac-funcall1> (#<fn:ac-lookup-global> foo) 1))

> (ac-compile '(~foo:bar 1))
(#<fn:ac-funcall1> (#<fn:ac-lookup-global> no) (#<fn:ac-funcall1> (#<fn:ac-lookup-global> foo) (#<fn:ac-funcall1> (#<fn:ac-lookup-global> bar) 1)))

> (ac-compile '(foo:~bar 1))
(#<fn:ac-funcall1> (#<fn:ac-lookup-global> foo) (#<fn:ac-funcall1> (#<fn:ac-lookup-global> no) (#<fn:ac-funcall1> (#<fn:ac-lookup-global> bar) 1)))


;=============================================================================
;  fn
;=============================================================================

> (ac-compile '(fn args args))
(racket-lambda args (racket-let ((args (#<fn:list->mlist> args))) args))


> (ac-compile '(fn (a b c) (list a b c)))
(racket-lambda (a b c) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))


> (ac-compile '(fn (a (o b 5) c) (list a b c)))
(racket-lambda (a (b 5) c) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))

> (fn (a (o b 5) c) (list a b c))
error: racket-lambda: default-value expression missing at: c in: (racket-lambda (a (b 5) c) (#<procedure:ac-funcall3> (#<procedure:ac-lookup-global> list) a b c))


> (ac-compile '(fn (a b (o c 5)) (list a b c)))
(racket-lambda (a b (c 5)) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))

> (ac-compile '(fn (a b (o c nil)) (list a b c)))
(racket-lambda (a b (c (#<fn:ac-lookup-global-arg> nil))) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))

> (ac-compile '(fn (a b (o c)) (list a b c)))
(racket-lambda (a b (c nil)) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))


> (ac-compile '(fn (a b . c) (list a b c)))
(racket-lambda (a b . c) (racket-let* ((c (#<fn:list->mlist> c))) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c)))


> (ac-compile '(fn (a b (c (d e f (g)))) (list a b c d e f g)))
(racket-lambda (a b g1) (racket-let* ((c (#<fn:car> g1)) (g1 (#<fn:cdr> g1)) (g2 (#<fn:car> g1)) (d (#<fn:car> g2)) (g2 (#<fn:cdr> g2)) (e (#<fn:car> g2)) (g2 (#<fn:cdr> g2)) (f (#<fn:car> g2)) (g2 (#<fn:cdr> g2)) (g3 (#<fn:car> g2)) (g (#<fn:car> g3))) (#<fn:ac-apply> (#<fn:ac-lookup-global> list) a b c d e f g)))


> (ac-compile '(fn (a (b) c) (fn (a b c) (list a b c))))
(racket-lambda (a g1 c) (racket-let* ((b (#<fn:car> g1))) (racket-lambda (a b c) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))))

> (ac-compile '(fn (a (b) c) (fn (a b (c)) (fn (a b c) (list a b c)))))
(racket-lambda (a g1 c) (racket-let* ((b (#<fn:car> g1))) (racket-lambda (a b g2) (racket-let* ((c (#<fn:car> g2))) (racket-lambda (a b c) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))))))

> (parameterize (ac-fn-required-args? #f
                 ac-fn-excess-args?   #t)
    (ac-compile '(fn (a (b) c) (fn (a b c) (list a b c)))))
(racket-lambda ((a nil) (g1 nil) (c nil) . g2) (racket-let* ((b (#<fn:car> g1))) (racket-lambda ((a nil) (b nil) (c nil) . g3) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))))

> (parameterize (ac-fn-required-args?       #f
                 ac-fn-excess-args?         #t
                 ac-fn-rigid-destructuring? #t)
    (ac-compile '(fn (a (b) c) (fn (a b c) (list a b c)))))
(racket-lambda ((a nil) (g1 nil) (c nil) . g2) (racket-let* ((b (racket-car g1)) (g1 (racket-cdr g1))) (racket-lambda ((a nil) (b nil) (c nil) . g3) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))))


> (ac-compile '(fn (a (b (c d (o e 10) (f) . g)) #:foo (o z 5) (o #:bar 15) . h) ac-local-env*)
(a b c d e f g foo z bar h)


> (ac-compile '((fn ((o a a)) a)))
((racket-lambda ((a (#<fn:ac-lookup-global-arg> a))) a))

(ac-compile '((fn ((o a (#<fn:ac-lookup-global a))) a)) nil)


> (ac-compile '(fn (a b c) (list a b c)))
(racket-lambda (a b c) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))

> (ac-compile '(fn (a b (o c 5)) (list a b c)))
(racket-lambda (a b (c 5)) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))

> (ac-compile '(fn (a (b) (o c 5)) (list a b c)))
(racket-lambda (a g1 (c 5)) (racket-let* ((b (#<fn:car> g1))) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c)))

> (ac-compile '(fn (a (b (c d)) (o c 5)) (list a b c d)))
(racket-lambda (a g1 (c 5)) (racket-let* ((b (#<fn:car> g1)) (g1 (#<fn:cdr> g1)) (g2 (#<fn:car> g1)) (c (#<fn:car> g2)) (g2 (#<fn:cdr> g2)) (d (#<fn:car> g2))) (#<fn:ac-funcall4> (#<fn:ac-lookup-global> list) a b c d)))

> (ac-compile '(fn (a (b (c d . e)) (o c 5) . f) (list a b c d e f)))
(racket-lambda (a g1 (c 5) . f) (racket-let* ((f (#<fn:list->mlist> f)) (b (#<fn:car> g1)) (g1 (#<fn:cdr> g1)) (g2 (#<fn:car> g1)) (c (#<fn:car> g2)) (g2 (#<fn:cdr> g2)) (d (#<fn:car> g2)) (g2 (#<fn:cdr> g2)) (e g2)) (#<fn:ac-apply> (#<fn:ac-lookup-global> list) a b c d e f)))

> (ac-compile '(fn (a (b (c (o d 10) . e)) (o c 5) . f) (list a b c d e f)))
(racket-lambda (a g1 (c 5) . f) (racket-let* ((f (#<fn:list->mlist> f)) (b (#<fn:car> g1)) (g1 (#<fn:cdr> g1)) (g2 (#<fn:car> g1)) (c (#<fn:car> g2)) (g2 (#<fn:cdr> g2)) (d (racket-if (#<fn:ac-true> (#<fn:cdr> g2)) (#<fn:car> g2) 10)) (g2 (#<fn:cdr> g2)) (e g2)) (#<fn:ac-apply> (#<fn:ac-lookup-global> list) a b c d e f)))

> (ac-compile '(fn (a (b (c (o d 10) . e)) :foo (o c 5) . f) (list a b c d e f foo)))
(racket-lambda (a g1 #:foo (foo nil) (c 5) . f) (racket-let* ((f (#<fn:list->mlist> f)) (b (#<fn:car> g1)) (g1 (#<fn:cdr> g1)) (g2 (#<fn:car> g1)) (c (#<fn:car> g2)) (g2 (#<fn:cdr> g2)) (d (racket-if (#<fn:ac-true> (#<fn:cdr> g2)) (#<fn:car> g2) 10)) (g2 (#<fn:cdr> g2)) (e g2)) (#<fn:ac-apply> (#<fn:ac-lookup-global> list) a b c d e f foo)))

> (ac-compile '(fn (a (b (c (o d 10) . e)) (o :foo 15) (o c 5) . f) (list a b c d e f foo)))
(racket-lambda (a g1 #:foo (foo 15) (c 5) . f) (racket-let* ((f (#<fn:list->mlist> f)) (b (#<fn:car> g1)) (g1 (#<fn:cdr> g1)) (g2 (#<fn:car> g1)) (c (#<fn:car> g2)) (g2 (#<fn:cdr> g2)) (d (racket-if (#<fn:ac-true> (#<fn:cdr> g2)) (#<fn:car> g2) 10)) (g2 (#<fn:cdr> g2)) (e g2)) (#<fn:ac-apply> (#<fn:ac-lookup-global> list) a b c d e f foo)))


> (ac-compile '(fn (a) (fn (b) (list a b c))))
(racket-lambda (a) (racket-lambda (b) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b (#<fn:ac-lookup-global-arg> c))))

> (ac-compile '(fn a a))
(racket-lambda a (racket-let ((a (#<fn:list->mlist> a))) a))

> (ac-compile '(fn (a) a))
(racket-lambda (a) a)

> (ac-compile '(fn (:a) a))
(racket-lambda (#:a (a nil)) a)

> (ac-compile '(fn ((o a 5)) a))
(racket-lambda ((a 5)) a)

> (ac-compile '(fn ((o :a 5)) a))
(racket-lambda (#:a (a 5)) a)

> (ac-compile '(fn (a . b) (list a b)))
(racket-lambda (a . b) (racket-let* ((b (#<fn:list->mlist> b))) (#<fn:ac-funcall2> (#<fn:ac-lookup-global> list) a b)))

> (ac-compile '(fn ((a)) a))
(racket-lambda (g1) (racket-let* ((a (#<fn:car> g1))) a))

> (ac-compile '(fn ((a (o b 5))) (list a b)))
(racket-lambda (g1) (racket-let* ((a (#<fn:car> g1)) (g1 (#<fn:cdr> g1)) (b (racket-if (#<fn:ac-true> (#<fn:cdr> g1)) (#<fn:car> g1) 5))) (#<fn:ac-funcall2> (#<fn:ac-lookup-global> list) a b)))

> (ac-compile '(fn ((a . b)) (list a b)))
(racket-lambda (g1) (racket-let* ((a (#<fn:car> g1)) (g1 (#<fn:cdr> g1)) (b g1)) (#<fn:ac-funcall2> (#<fn:ac-lookup-global> list) a b)))


;=============================================================================
;  %nocompile
;=============================================================================

> (ac-compile `(%nocompile (+ 1 2 3 4 5)))
(+ 1 2 3 4 5)

> (ac-compile `(,%nocompile (+ 1 2 3 4 5)))
(+ 1 2 3 4 5)

> (type (ac-compile `(,%nocompile (+ 1 2 3 4 5))))
cons


> (ac-compile `(%nocompile + 1 2 3 4 5))
(racket-begin + 1 2 3 4 5)

> (ac-compile `(,%nocompile + 1 2 3 4 5))
(racket-begin + 1 2 3 4 5)

> (type (ac-compile `(,%nocompile + 1 2 3 4 5)))
cons


> (ac-compile '(%nocompile 5 10 (foo 10) (bar (qux (%compile (corge)))) (%compile (foo 10)) (%compile 5)))
(racket-begin 5 10 (foo 10) (bar (qux (%compile (corge)))) (%compile (foo 10)) (%compile 5))

> (ac-compile `(%nocompile 5 10 (foo 10) (bar (qux ,(ac-compile '(corge)))) ,(ac-compile '(foo 10)) ,(ac-compile '5)))
(racket-begin 5 10 (foo 10) (bar (qux (#<fn:ac-funcall0> (#<fn:ac-lookup-global> corge)))) (#<fn:ac-funcall1> (#<fn:ac-lookup-global> foo) 10) 5)

> (%nocompile (racket-parameterize ((racket-current-namespace (racket-current-namespace))) (racket-current-namespace)))
#<namespace:0>

> (%nocompile (racket-parameterize ((racket-current-namespace (racket-current-namespace)))
    (%compile (+ 10 5) (+ 15 20))))
error: reference to undefined identifier: %compile

> (eval `(%nocompile (racket-parameterize ((racket-current-namespace (racket-current-namespace)))
           ,@(ac-args '((+ 10 5) (+ 15 20))))))
35

> (let ac-compile nil
    (%nocompile (+ 10 5)))
15

> (let %nocompile nil
    (%nocompile (+ 10 5)))
error: function call on inappropriate object () 15


;=============================================================================
;  %splice
;=============================================================================

> (+ (%splice 1 2 3))
6

> ((%splice + 1 2 3) 4 5 6)
21

> ((%splice + 1 2 3) (%splice 4 5 6))
21

> (ac-compile '(+ (%splice 1 2 3)))
(#<fn:ac-funcall3> (#<fn:ac-lookup-global> +) 1 2 3)


;=============================================================================
;  pipe-from
;=============================================================================

> (w/pipe-from x "echo 'foo\nbar\nqux'" (readlines x))
("foo" "bar" "qux")

> (pipe-lines "echo 'foo\nbar\nqux'")
("foo" "bar" "qux")


;=============================================================================
;  Function calls
;=============================================================================

> (ac-compile '(foo))
(#<fn:ac-funcall0> (#<fn:ac-lookup-global> foo))

> (ac-compile '(foo 1))
(#<fn:ac-funcall1> (#<fn:ac-lookup-global> foo) 1)

> (ac-compile '(foo 1 2))
(#<fn:ac-funcall2> (#<fn:ac-lookup-global> foo) 1 2)

> (ac-compile '(foo 1 2 3))
(#<fn:ac-funcall3> (#<fn:ac-lookup-global> foo) 1 2 3)

> (ac-compile '(foo 1 2 3 4))
(#<fn:ac-funcall4> (#<fn:ac-lookup-global> foo) 1 2 3 4)

> (ac-compile '(foo 1 2 3 4 5))
(#<fn:ac-apply> (#<fn:ac-lookup-global> foo) 1 2 3 4 5)

> (ac-compile '(foo :a 1))
(#<fn:ac-apply> (#<fn:ac-lookup-global> foo) #:a 1)


;=============================================================================
;  Function names
;=============================================================================

> ac-apply
#<fn:ac-apply>

> apply
#<fn:apply>

> is
#<fn:is>

> +
#<fn:+>

> <
#<fn:<>

> >
#<fn:>>

> ac-apply-non-fn
#<fn:ac-apply-non-fn>

> ac-global-assign-raw
#<fn:ac-global-assign-raw>

> bound
#<fn:bound>

> cons
#<fn:cons>

> list
#<fn:list>

> sref
#<fn:sref>

> ac-tnil
#<fn:ac-tnil>


;=============================================================================
;  sig
;=============================================================================

> (sig 'ac-deep-toarc)
(x)

> (type (sig 'ac-deep-toarc))
cons


> (sig 'namespace-get)
(runtime varname (o default))

> (type (sig 'namespace-get))
cons

> (type (car (cddr (sig 'namespace-get))))
cons


> (sig 'uniq)
((o name (quote g)) (o num))

> (type (sig 'uniq))
cons

> (type (car (sig 'uniq)))
cons


> (sig 'ac-var)
(x (o def))

> (type (sig 'ac-var))
cons

> (type (cadr (sig 'ac-var)))
cons


> (sig 'bound)
(name)

> (type (sig 'bound))
cons


> (sig 'err)
(x . rest)

> (type (sig 'err))
cons


> (sig 'cons)
(x y)

> (type (sig 'cons))
cons


> (sig 'list)
args

> (type (sig 'list))
sym


> (sig 'ac-apply-non-fn)
(x (o k) (o d))

> (type (sig 'ac-apply-non-fn))
cons

> (type (cadr (sig 'ac-apply-non-fn)))
cons


> (sig 'ac-apply)
(f . racket-arg-list)

> (type (sig 'ac-apply))
cons


> (sig 'apply)
(f . args)

> (type (sig 'apply))
cons


> (sig 'ac-global-assign-raw)
(a b)

> (type (sig 'ac-global-assign-raw))
cons


> (sig 'sref)
(f val key (o ind))

> (type (sig 'sref))
cons

> (type (cadr (cddr (sig 'sref))))
cons


> (sig 'is)
args

> (type (sig 'is))
sym


> (sig 'eval)
(x (o runtime))

> (type (sig 'eval))
cons

> (type (cadr (sig 'eval)))
cons


;=============================================================================


> (sig 'ac-tnil)
(x)

> (type (sig 'ac-tnil))
cons


> (sig 'assign)
args

> (type (sig 'assign))
sym


> (sig 'fn)
(parms . body)

> (type (sig 'fn))
cons


> (sig 'ac-compile)
(x)

> (type (sig 'ac-compile))
cons


> (sig 'do)
args

> (type (sig 'do))
sym


> (sig 'isa)
(x y)

> (type (sig 'isa))
cons


;=============================================================================
;  Macros
;=============================================================================

> (mac macfoo (x) (+ 1 2) (+ 1 2))
#<mac:macfoo>

> (macfoo)
error: #<procedure>: expects 1 argument, given 0

> (macfoo 5)
3


;=============================================================================
;  Assignment
;=============================================================================

> (macex-all '(= (foo bar) 5))
(sref foo 5 bar)

> (macex-all '(= (foo 'bar) 5))
((fn (g1) (sref foo 5 g1)) (quote bar))

> (macex-all '(= (foo (bar qux)) 5))
((fn (g1) (sref foo 5 g1)) (bar qux))


> (macex-all '(zap + (foo bar) 1))
(sref foo (+ (foo bar) 1) bar)

> (macex-all '(zap + (foo 'bar) 1))
((fn (g1) (sref foo (+ (foo g1) 1) g1)) (quote bar))


> (macex-all '(zap + (foo (bar)) 1))
((fn (g1) (sref foo (+ (foo g1) 1) g1)) (bar))

> (macex-all '(zap + (foo (bar qux)) 1))
((fn (g1) (sref foo (+ (foo g1) 1) g1)) (bar qux))


> (macex-all '(zap + (foo (bar) (qux)) 1))
((fn (g1 g2) (sref foo (+ (foo g1 g2) 1) g1 g2)) (bar) (qux))


> (macex-all '(or= (foo (bar qux)) 5))
((fn (g1) (if (no (foo g1)) (sref foo 5 g1))) (bar qux))


> (macex-all '(push 5 (foo (bar qux))))
((fn (g1) (sref foo (cons 5 (foo g1)) g1)) (bar qux))

> (macex-all '(pushnew 5 (foo (bar qux))))
((fn (g1) (sref foo (adjoin 5 (foo g1)) g1)) (bar qux))


> (ac-compile '(swap foo bar))
((racket-lambda (g1) (#<fn:ac-global-assign-raw> (racket-quote foo) (#<fn:ac-lookup-global-arg> bar)) (#<fn:ac-global-assign-raw> (racket-quote bar) g1)) (#<fn:ac-lookup-global-arg> foo))

> (macex-all '(swap foo bar))
((fn (g1) (assign foo bar) (assign bar g1)) foo)

> (macex-all '(swap (foo 'bar) (bar 'foo)))
((fn (g1 g2) ((fn (g3) (sref foo (bar g2) g1) (sref bar g3 g2)) (foo g1))) (quote bar) (quote foo))

> (macex-all '(swap (foo 'bar) (bar (qux foo))))
((fn (g1 g2) ((fn (g3) (sref foo (bar g2) g1) (sref bar g3 g2)) (foo g1))) (quote bar) (qux foo))

> (macex-all '(swap (foo '(bar)) (bar (qux foo))))
((fn (g1 g2) ((fn (g3) (sref foo (bar g2) g1) (sref bar g3 g2)) (foo g1))) (quote (bar)) (qux foo))

> (macex-all '(swap (foo (bar qux)) (bar (qux foo))))
((fn (g1 g2) ((fn (g3) (sref foo (bar g2) g1) (sref bar g3 g2)) (foo g1))) (bar qux) (qux foo))


> (macex-all '(togglemem x (foo (bar qux))))
((fn (g3) (sref foo ((fn (g1 g2) (if (mem g1 g2) (rem g1 g2) (adjoin g1 g2))) x (foo g3)) g3)) (bar qux))


> (ac-compile '(rotate a b c d))
((racket-lambda (g1) (#<fn:ac-global-assign-raw> (racket-quote a) (#<fn:ac-lookup-global-arg> b)) (#<fn:ac-global-assign-raw> (racket-quote b) (#<fn:ac-lookup-global-arg> c)) (#<fn:ac-global-assign-raw> (racket-quote c) (#<fn:ac-lookup-global-arg> d)) (#<fn:ac-global-assign-raw> (racket-quote d) g1)) (#<fn:ac-lookup-global-arg> a))

> (macex-all '(rotate a b c d))
((fn (g1) (assign a b) (assign b c) (assign c d) (assign d g1)) a)

> (macex-all '(rotate (a b) (c d) (e f)))
((fn (g1) (sref a (c d) b) (sref c (e f) d) (sref e g1 f)) (a b))

> (macex-all '(rotate (a 'b) (c d) (e (f g))))
((fn (g1 g2) ((fn (g3) (sref a (c d) g1) (sref c (e g2) d) (sref e g3 g2)) (a g1))) (quote b) (f g))

> (macex-all '(rotate (a 'b) (c (d 5)) (e (f g))))
((fn (g1 g2 g3) ((fn (g4) (sref a (c g2) g1) (sref c (e g3) g2) (sref e g4 g3)) (a g1))) (quote b) (d 5) (f g))

> (macex-all '(rotate (foo (bar qux)) (foo (bar qux)) (foo (bar qux))))
((fn (g1 g2 g3) ((fn (g4) (sref foo (foo g2) g1) (sref foo (foo g3) g2) (sref foo g4 g3)) (foo g1))) (bar qux) (bar qux) (bar qux))


> (macex-all '(push 1 (pop x)))
(sref push (cons 1 ((ac-fn (g1) ((ac-fn (g2) (ac-assign x (cdr g1)) g2) (car g1))) x)) x)

> (macex-all '(= (if (foo a) b c d) 5))
((fn (g1 g2) (ac-if g2 (ac-assign a g1) (ac-assign b g1))) 5 (foo a))

> (macex-all '(= (if (foo a) b c (bar d) e f) 5))
((fn (g1 g2 g3) (ac-if g2 (ac-assign a g1) (ac-assign b g1) g3 (ac-assign e g1) (ac-assign f g1))) 5 (foo a) (bar d))


;=============================================================================
;  quasiquote
;=============================================================================

> (macex1 '`(foo qux ,@bar))
(#<fn:cons> (#<mac:quote> foo) (#<fn:cons> (#<mac:quote> qux) (#<fn:mappend> bar nil)))

> (macex1 '`(foo ,@bar qux))
(#<fn:cons> (#<mac:quote> foo) (#<fn:mappend> bar (#<fn:cons> (#<mac:quote> qux) nil)))


> (let name 'foo
    (qq-expand `',name))
(#<fn:cons> (#<mac:quote> quote) (#<fn:cons> (#<mac:quote> foo) nil))

> (let name '(foo bar qux)
    (qq-expand `',@name))
(#<fn:cons> (#<mac:quote> quote) (#<fn:cons> (#<mac:quote> foo) (#<fn:cons> (#<mac:quote> bar) (#<fn:cons> (#<mac:quote> qux) nil))))


> (macex-all `foo)
foo

> (qq-expand `foo)
(#<mac:quote> foo)


> (macex-all `,(+ 1 2))
3

> (qq-expand `,(+ 1 2))
(#<mac:quote> 3)


> (macex-all `,@(list 1 2 3))
error: ,@ cannot be used immediately after `

> (qq-expand `,@(list 1 2 3))
error: ,@ cannot be used immediately after `


> (macex-all '`(foo bar qux corge))
(cons (quote foo) (cons (quote bar) (cons (quote qux) (cons (quote corge) nil))))

> (qq-expand '`(foo bar qux corge))
(#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<mac:quote>) (#<fn:cons> (#<mac:quote> foo) nil)) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<mac:quote>) (#<fn:cons> (#<mac:quote> bar) nil)) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<mac:quote>) (#<fn:cons> (#<mac:quote> qux) nil)) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<mac:quote>) (#<fn:cons> (#<mac:quote> corge) nil)) (#<fn:cons> (#<mac:quote> nil) nil))) nil))) nil))) nil)))


> (macex-all '`(foo bar ,@qux ,corge))
(cons (quote foo) (cons (quote bar) (mappend qux (cons corge nil))))

> (qq-expand '`(foo bar ,@qux ,corge))
(#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<mac:quote>) (#<fn:cons> (#<mac:quote> foo) nil)) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<mac:quote>) (#<fn:cons> (#<mac:quote> bar) nil)) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<fn:mappend>) (#<fn:cons> (#<mac:quote> qux) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<mac:quote> corge) (#<fn:cons> (#<mac:quote> nil) nil))) nil))) nil))) nil)))


> (macex-all '`(foo (bar nou) ,@qux ,corge))
(cons (quote foo) (cons (cons (quote bar) (cons (quote nou) nil)) (mappend qux (cons corge nil))))

> (qq-expand '`(foo (bar nou) ,@qux ,corge))
(#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<mac:quote>) (#<fn:cons> (#<mac:quote> foo) nil)) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<mac:quote>) (#<fn:cons> (#<mac:quote> bar) nil)) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<mac:quote>) (#<fn:cons> (#<mac:quote> nou) nil)) (#<fn:cons> (#<mac:quote> nil) nil))) nil))) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<fn:mappend>) (#<fn:cons> (#<mac:quote> qux) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<mac:quote> corge) (#<fn:cons> (#<mac:quote> nil) nil))) nil))) nil))) nil)))


> (macex-all '`(foo `(bar nou) ,@qux ,corge))
(cons (quote foo) (cons (cons (quote cons) (cons (cons (quote quote) (cons (quote bar) nil)) (cons (cons (quote cons) (cons (cons (quote quote) (cons (quote nou) nil)) (cons (quote nil) nil))) nil))) (mappend qux (cons corge nil))))

> (qq-expand '`(foo `(bar nou) ,@qux ,corge))
(#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<mac:quote>) (#<fn:cons> (#<mac:quote> foo) nil)) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<mac:quote>) (#<fn:cons> (#<mac:quote> #<fn:cons>) nil)) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<mac:quote>) (#<fn:cons> (#<mac:quote> #<mac:quote>) nil)) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<mac:quote>) (#<fn:cons> (#<mac:quote> bar) nil)) (#<fn:cons> (#<mac:quote> nil) nil))) nil))) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<mac:quote>) (#<fn:cons> (#<mac:quote> #<fn:cons>) nil)) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<mac:quote>) (#<fn:cons> (#<mac:quote> #<mac:quote>) nil)) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<mac:quote>) (#<fn:cons> (#<mac:quote> nou) nil)) (#<fn:cons> (#<mac:quote> nil) nil))) nil))) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<mac:quote>) (#<fn:cons> (#<mac:quote> nil) nil)) (#<fn:cons> (#<mac:quote> nil) nil))) nil))) nil))) (#<fn:cons> (#<mac:quote> nil) nil))) nil))) nil))) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<fn:mappend>) (#<fn:cons> (#<mac:quote> qux) (#<fn:cons> (#<fn:cons> (#<mac:quote> #<fn:cons>) (#<fn:cons> (#<mac:quote> corge) (#<fn:cons> (#<mac:quote> nil) nil))) nil))) nil))) nil)))


;=============================================================================
;  quasisyntax
;=============================================================================

> (macex1 '#`(foo qux ,@bar))
(#<fn:cons> foo (#<fn:cons> qux (#<fn:mappend> bar nil)))

> (macex1 '#`(foo ,@bar qux))
(#<fn:cons> foo (#<fn:mappend> bar (#<fn:cons> qux nil)))


> (let name 'foo
    (qq-expand #`',name))
(#<fn:cons> (#<mac:quote> #<mac:quote>) (#<fn:cons> (#<mac:quote> foo) nil))

> (let name '(foo bar qux)
    (qq-expand #`',@name))
(#<fn:cons> (#<mac:quote> #<mac:quote>) (#<fn:cons> (#<mac:quote> foo) (#<fn:cons> (#<mac:quote> bar) (#<fn:cons> (#<mac:quote> qux) nil))))


> (let body '(1 2 3)
    (macex1 #`(fn ('a 'b 'c) (,@body))))
(g4 racket-lambda (a b c) (#<fn:ac-funcall2> 1 2 3))

> (let body '(1 2 3)
    (qq-expand #`(fn (('o '_)) (,@body))))
(#<fn:cons> (#<mac:quote> #<mac:fn>) (#<fn:cons> (#<fn:cons> (#<fn:cons> (#<mac:quote> o) (#<fn:cons> (#<mac:quote> _) nil)) nil) (#<fn:cons> (#<fn:cons> (#<mac:quote> 1) (#<fn:cons> (#<mac:quote> 2) (#<fn:cons> (#<mac:quote> 3) nil))) nil)))


> (macex1 #`+)
#<fn:+>

> (qq-expand #`+)
(#<mac:quote> #<fn:+>)


> (macex1 #`'+)
+

> (qq-expand #`'+)
(#<mac:quote> +)


> (macex1 #`(+ 1 2))
(#<fn:+> 1 2)

> (macex1 #`'(+ 1 2))
(+ 1 2)


> (macex1 #`,(+ 1 2))
3

> (qq-expand #`,(+ 1 2))
(#<mac:quote> 3)


> (macex-all #`,@(list 1 2 3))
error: ,@ cannot be used immediately after #`

> (qq-expand #`,@(list 1 2 3))
error: ,@ cannot be used immediately after #`


> (macex-all '#`(foo bar qux corge))
(cons foo (cons bar (cons qux (cons corge nil))))

> (qq-expand '#`(foo bar qux corge))
(#<fn:cons> (#<mac:quote> quasisyntax) (#<fn:cons> (#<fn:cons> (#<mac:quote> foo) (#<fn:cons> (#<mac:quote> bar) (#<fn:cons> (#<mac:quote> qux) (#<fn:cons> (#<mac:quote> corge) nil)))) nil))


> (macex-all '#`(foo bar ,@qux ,corge))
(cons foo (cons bar (mappend qux (cons corge nil))))

> (qq-expand '#`(foo bar ,@qux ,corge))
(#<fn:cons> (#<mac:quote> quasisyntax) (#<fn:cons> (#<fn:cons> (#<mac:quote> foo) (#<fn:cons> (#<mac:quote> bar) (#<fn:mappend> qux (#<fn:cons> corge nil)))) nil))


> (macex-all '#`(foo (bar nou) ,@qux ,corge))
(cons foo (cons (cons bar (cons nou nil)) (mappend qux (cons corge nil))))

> (qq-expand '#`(foo (bar nou) ,@qux ,corge))
(#<fn:cons> (#<mac:quote> quasisyntax) (#<fn:cons> (#<fn:cons> (#<mac:quote> foo) (#<fn:cons> (#<fn:cons> (#<mac:quote> bar) (#<fn:cons> (#<mac:quote> nou) nil)) (#<fn:mappend> qux (#<fn:cons> corge nil)))) nil))


> (macex-all '#`(foo #`(bar nou) ,@qux ,corge))
(cons foo (cons (cons cons (cons bar (cons (cons cons (cons nou (cons nil nil))) nil))) (mappend qux (cons corge nil))))

> (qq-expand '#`(foo #`(bar nou) ,@qux ,corge))
(#<fn:cons> (#<mac:quote> quasisyntax) (#<fn:cons> (#<fn:cons> (#<mac:quote> foo) (#<fn:cons> (#<fn:cons> (#<mac:quote> quasisyntax) (#<fn:cons> (#<fn:cons> (#<mac:quote> bar) (#<fn:cons> (#<mac:quote> nou) nil)) nil)) (#<fn:mappend> qux (#<fn:cons> corge nil)))) nil))


;=============================================================================
;  expand=
;=============================================================================

> (expand= 'foo 10)
(#<mac:with> nil (#<mac:assign> foo 10))


> (expand= 'foo.bar 10)
(#<mac:with> nil (#<mac:sref-mac> foo 10 bar))

> (expand= '(foo bar) 10)
(#<mac:with> nil (#<mac:sref-mac> foo 10 bar))

> (expand= 'foo!bar 10)
(#<mac:with> (g1 (quote bar)) (#<mac:sref-mac> foo 10 g1))


> (expand= '(car foo) 10)
(#<mac:with> nil (#<mac:sref-mac> car 10 foo))

> (expand= '(car (foo bar)) 10)
(#<mac:with> (g1 (foo bar)) (#<mac:sref-mac> car 10 g1))


> (expand= '(car (foo bar) (qux)) 10)
(#<mac:with> (g1 (foo bar) g2 (qux)) (#<mac:sref-mac> car 10 g1 g2))

> (macex-all (expand= '(car (foo bar) (qux)) 10))
((fn (g1 g2) (sref car 10 g1 g2)) (foo bar) (qux))

> (with (foo  (fn (x) x)
         bar  5
         qux  (fn () 15))
    (= (car (foo bar) (qux)) 10))
error: can't set reference #<procedure:car> 5 10 15


> (expand= '(assoc (foo 'bar) 'qux) 5)
(#<mac:with> (g1 (foo #<quoted>) g2 #<quoted>) (#<mac:sref-mac> assoc 5 g1 g2))

> (macex-all (expand= '(assoc (foo 'bar) 'qux) 5))
((fn (g1 g2) (sref assoc 5 g1 g2)) (foo (quote bar)) (quote qux))


> (expand= '(assoc foo bar) 10)
(#<mac:with> nil (#<mac:sref-mac> assoc 10 foo bar))

> (expand= '(assoc foo 'bar) 10)
(#<mac:with> (g1 #<quoted>) (#<mac:sref-mac> assoc 10 foo g1))

> (expand= '(alref foo 'bar) 10)
(#<mac:with> (g1 #<quoted>) (#<mac:sref-mac> alref 10 foo g1))


> (expand= '(foo (car (car foo))) 10)
(#<mac:with> (g1 (car (car foo))) (#<mac:sref-mac> foo 10 g1))

> (expand= '(foo:car:car foo) 10)
(#<mac:with> (g1 (car (car foo))) (#<mac:sref-mac> foo 10 g1))


> (expand= '(car (car (car foo))) 10)
(#<mac:with> (g1 (car (car foo))) (#<mac:sref-mac> car 10 g1))

> (expand= '(car:car:car foo) 10)
(#<mac:with> (g1 (car (car foo))) (#<mac:sref-mac> car 10 g1))


> (expand= '(~foo:bar:qux (~~bar bar:qux 5)) 10)
(#<mac:with> (g1 (foo (bar (qux (no (no (bar (#<mac:compose> bar qux) 5))))))) (#<mac:sref-mac> no 10 g1))

> (macex-all (expand= '(~foo:bar:qux (~~bar bar:qux 5)) 10))
((fn (g1) (sref no 10 g1)) (foo (bar (qux (no (no (bar (compose bar qux) 5)))))))

> (ac-compile (expand= '(~foo:bar:qux (~~bar bar:qux 5)) 10))
u


;=============================================================================
;  setforms
;=============================================================================

> (setforms 'foo)
((g1 foo) g1 (fn (g2) (#<mac:assign> foo g2)))

> (setforms '(car 5))
((g1 5) (car g1) (fn (g2) (#<fn:scar> g1 g2)))

> (setforms '(car (car (car 5))))
((g1 (car (car 5))) (car g1) (fn (g2) (#<fn:scar> g1 g2)))

> (setforms '(foo 5))
((g1 foo g3 5) (g1 g3) (fn (g2) (#<mac:sref-mac> g1 g2 g3)))


;=============================================================================
;  ssyntax
;=============================================================================

> (expand-full '(~foo:bar:qux (~~bar bar:qux 5)))
(no (foo (bar (qux (no (no (bar (#<mac:compose> bar qux) 5)))))))


;=============================================================================
;  Keyword args
;=============================================================================

> ((fn (:a b c) (list a b c)) 1)
error: #<procedure>: expects 2 arguments plus an optional argument with keyword #:a, given 1: 1

> ((fn (:a b c) (list a b c)) 1 2)
(nil 1 2)

> ((fn (:a b c) (list a b c)) 1 2 3)
error: #<procedure>: expects 2 arguments plus an optional argument with keyword #:a, given 3: 1 2 3

> ((fn (:a b c) (list a b c)) 1 2 :a 3)
(3 1 2)

> ((fn (:a b c) (list a b c)) :a 3 1 2)
(3 1 2)


> ((fn ((o :a) b c) (list a b c)) 1 2)
(nil 1 2)

> ((fn ((o :a) b c) (list a b c)) 1 2 :a 10)
(10 1 2)

> ((fn ((o :a 15) b c) (list a b c)) 1 2)
(15 1 2)

> ((fn ((o :a 15) b c) (list a b c)) 1 2 :a 3)
(3 1 2)

> ((fn (b c (o :a 15)) (list a b c)) 1 2)
(15 1 2)

> ((fn (b c (o :a 15)) (list a b c)) 1 2 :a 3)
(3 1 2)


> ((fn (:a (b c)) (list a b c)))
error: #<procedure>: expects 1 argument plus an optional argument with keyword #:a, given 0

> ((fn (:a (b c)) (list a b c)) 1)
error: mcar: expects argument of type <mutable-pair>; given 1

> ((fn (:a (b c)) (list a b c)) 1 2)
error: #<procedure>: expects 1 argument plus an optional argument with keyword #:a, given 2: 1 2

> ((fn (:a (b c)) (list a b c)) '(1 2))
(nil 1 2)

> ((fn (:a (b c)) (list a b c)) '(1 2) :a 5)
(5 1 2)


> (def foo (:a :b)
    (list a b))
#<fn:foo>

> (foo 1 2)
error: procedure foo: expects 0 arguments plus optional arguments with keywords #:a and #:b, given 2: 1 2

> (foo :a 1)
(1 nil)

> (foo :b 2)
(nil 2)

> (foo :a 1 2)
error: foo: no case matching 1 non-keyword argument; arguments were: 2 #:a 1

> (foo :a 1 :b 2)
(1 2)

> (foo :b 2 :a 1)
(1 2)


> (def foo (:a (o :b 5))
    (list a b))
*** redefining foo
#<fn:foo>

> (foo :a 1)
(1 5)

> (foo :a 1 :b nil)
(1 5)

> (foo :a 1 :b 2)
(1 2)


> (def foo (:a :b . rest)
    (list a b rest))
*** redefining foo
#<fn:foo>

> (apply foo :a 1 :b 2)
(1 2 nil)

> (apply foo :a 1 :b 2 3 (list 4 5))
(1 2 (3 4 5))



;=============================================================================
;  Keyword destructuring
;=============================================================================

> (let (:a :b :c) (obj a 1 b 2)
    (list a b c))
(1 2 nil)

;; TODO: not sure about this
> (let (:a (:b :c)) (obj a 1 b (obj c 2))
    (list a b c))
(list 1 #hash() 2)

> (let (:a :b (o :c 5)) (obj a 1 b 2)
    (list a b c))
(1 2 5)

> (let (:a :b (o :c 5) . d) (obj a 1 b 2)
    (list a b c d))
(1 2 5 #hash((a . 1) (b . 2)))

> (let (:a :b . c) (obj a 1 b 2)
    (list a b c))
(1 2 #hash((a . 1) (b . 2)))

> (let (:a :b :c) (obj a 1 b 2 c 3)
    (list a b c))
(1 2 3)

> (let (:a :b :c) (obj a 1 b 2 c 3 d 4)
    (list a b c))
(1 2 3)


> (ac-compile '(let (:a :b :c) (obj a 1 b 2 c 3)
                 (list a b c)))
((racket-lambda (g1) (racket-let* ((a (#<fn:ac-funcall1> g1 (racket-quote a))) (b (#<fn:ac-funcall1> g1 (racket-quote b))) (c (#<fn:ac-funcall1> g1 (racket-quote c)))) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))) (#<fn:listtab> (#<fn:list> (#<fn:list> #<quoted> 1) (#<fn:list> #<quoted> 2) (#<fn:list> #<quoted> 3))))

> (ac-compile '(let (:a :b . c) (obj a 1 b 2)
                 (list a b c)))
((racket-lambda (g1) (racket-let* ((a (#<fn:ac-funcall1> g1 (racket-quote a))) (b (#<fn:ac-funcall1> g1 (racket-quote b))) (c g1)) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))) (#<fn:listtab> (#<fn:list> (#<fn:list> #<quoted> 1) (#<fn:list> #<quoted> 2))))

> (ac-compile '(let (:a :b (o :c 5)) (obj a 1 b 2)
                 (list a b c)))
((racket-lambda (g1) (racket-let* ((a (#<fn:ac-funcall1> g1 (racket-quote a))) (b (#<fn:ac-funcall1> g1 (racket-quote b))) (c (#<fn:ac-funcall2> g1 (racket-quote c) 5))) (#<fn:ac-funcall3> (#<fn:ac-lookup-global> list) a b c))) (#<fn:listtab> (#<fn:list> (#<fn:list> #<quoted> 1) (#<fn:list> #<quoted> 2))))


> (ac-compile '(fn ((:a)) a))
(racket-lambda (g1) (racket-let* ((a (#<fn:ac-funcall1> g1 (racket-quote a)))) a))

;; TODO: not sure about this
> (ac-compile '(fn ((a (o :b 5))) (list a b)))
(racket-lambda (g1) (racket-let* ((a (#<fn:car> g1)) (g1 (#<fn:cdr> g1)) (b (#<fn:ac-funcall2> g1 (racket-quote b) 5))) (#<fn:ac-funcall2> (#<fn:ac-lookup-global> list) a b)))


> (let (:a :b :c) '((b 2) (a 1) (c 3))
    (list a b c))
(1 2 3)


;=============================================================================
;  Hygienic macros
;=============================================================================

> (mac unless (test . body)
    `(if (no ,test) (do ,@body)))
*** redefining unless
#<mac:unless>

> (let foo nil
    (unless foo 5))
5

> (let foo nil
    (let no (fn (x) nil)
      (unless foo 5)))
nil


> (mac unless (test . body)
    `(,if (,no ,test) (,do ,@body)))
*** redefining unless
#<mac:unless>

> (let foo nil
    (unless foo 5))
5

> (let foo nil
    (let no (fn (x) nil)
      (unless foo 5)))
5


> (mac unless (test . body)
    #`(if (no test) (do ,@body)))
*** redefining unless
#<mac:unless>

> (let foo nil
    (unless foo 5))
5

> (let foo nil
    (let no (fn (x) nil)
      (unless foo 5)))
5


;=============================================================================
;  Optional args
;=============================================================================

> (def foo (a (o b 5) (o c 10))
    (list a b c))

> (foo 1)
(1 5 10)

> (foo 1 nil nil)
(1 5 10)

> (foo 1 nil 3)
(1 5 3)

> (foo 1 2 3)
(1 2 3)


> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2 (3)) nil)
(1 2 5 nil nil)

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2 (3)) nil nil)
(1 2 5 nil nil)

> ((fn (a (b) (o c 5) (o d) . rest) (list a b c d rest)) 1 '(2 (3)) nil nil 5 6 7)
(1 2 5 nil (5 6 7))


;=============================================================================
;  Lists
;=============================================================================

> (list*)
nil

> (list* 1)
1

> (list* 1 2)
(1 . 2)

> (list* 1 2 3)
(1 2 . 3)

> (list* 1 2 (list 3 4 5))
(1 2 3 4 5)

> (list* (list 1 2 3))
(1 2 3)


> (join '(1 2) 3)
(1 2 . 3)


> (mappend [list _ 1] '(a b c d))
(a 1 b 1 c 1 d 1)

> (mappend [list _ 1] '(a b c . d))
(a 1 b 1 c 1 . d)


;=============================================================================
;  readline
;=============================================================================

> (readline:instring "\n")
""

> (readline:instring "foo\r\n")
"foo"


> (= foo (instring "foo\r\n"))
#<input-port:string>

> (readline foo)
"foo"

> (peekc foo)
nil


> (= foo (instring "foo\ra"))
#<input-port:string>

> (readline foo)
"foo\ra"

> (peekc foo)
nil


> (= foo (instring "foo\r"))
#<input-port:string>

;; TODO: not sure about this
> (readline foo)
"foo\r"

> (peekc foo)
nil


;=============================================================================
;  Parameters
;=============================================================================

> stdout
#<output-port:stdout>

> (stdout)
#<output-port:stdout>


> (w/stdout stderr stdout)
#<output-port:stderr>

> (w/stdout stderr (stdout))
#<output-port:stderr>


> (= stdout stderr)
#<output-port:stderr>

> stdout
#<output-port:stderr>

> (stdout)
#<output-port:stderr>


> ((fn ((o a stdout)) a))
#<output-port:stdout>


> (parameter foo 5)
5

> foo
5

> (w/foo 10 foo)
10

> foo
5


> (= foo 50)
50

> foo
50

> (w/foo 15 foo)
15

> foo
50


;=============================================================================
;  annotate
;=============================================================================

> annotate
#<fn:annotate>

> (annotate '(1 2 3) '(4 5 6))
#(tagged (1 2 3) (4 5 6))

> (annotate + -)
#(tagged #<fn:+> #<fn:->)

> assign
#<mac:assign>

> fn
#<mac:fn>

> if
#<mac:if>

> quote
#<mac:quote>

> quasiquote
#<mac:quasiquote>

> quasisyntax
#<mac:quasisyntax>

> %nocompile
#<mac:%nocompile>

> %splice
#<mac:%splice>


;=============================================================================
;  uniq
;=============================================================================

> (w/uniq-counter 1 (uniq))
g1

> (w/uniq-counter 1 (uniq "foo"))
foo1

> (w/uniq-counter 1 (uniq) uniq-counter)
2

> (w/uniq-counter 1 (uniq "foo") uniq-counter)
2

> (w/uniq-counter 1 (uniq "foo" 5))
foo5

> (w/uniq-counter 1 (uniq "foo" 5) uniq-counter)
1

> (w/uniq-counter 1 (uniq) (uniq))
g2


;=============================================================================
;  Pipe composition
;=============================================================================

> (quote : )
nil

> (ac-compile '(fn : a b))
(racket-lambda (a b) (#<fn:ac-lookup-global-arg> nil))

> (ac-compile '(fn : (a b)))
(racket-lambda (g1) (racket-let* ((a (#<fn:car> g1)) (g1 (#<fn:cdr> g1)) (b (#<fn:car> g1))) (#<fn:ac-lookup-global-arg> nil)))


> '(+ 1 2 : + 3 4)
(+ 1 2 : + 3 4)

> (ac-compile '(+ 1 2 : + 3 4))
(#<fn:ac-funcall3> (#<fn:ac-lookup-global> +) 1 2 (#<fn:ac-funcall2> (#<fn:ac-lookup-global> +) 3 4))


> (+ 1 2 : + 3 4)
10

> (+ 1 2 (+ 3 4))
10


> '(+ 1 2 : + 3 4 : + 5 6)
(+ 1 2 : + 3 4 : + 5 6)

> (ac-compile '(+ 1 2 : + 3 4 : + 5 6))
(#<fn:ac-funcall3> (#<fn:ac-lookup-global> +) 1 2 (#<fn:ac-funcall3> (#<fn:ac-lookup-global> +) 3 4 (#<fn:ac-funcall2> (#<fn:ac-lookup-global> +) 5 6)))


> (+ 1 2 : + 3 4 : + 5 6)
21

> (+ 1 2 (+ 3 4 (+ 5 6)))
21


> (ac-compile '(accum acc
                 (each x args
                   (acc (* 2 x)))))
((racket-lambda (g1) ((racket-lambda (acc) ((racket-lambda nil (#<fn:eachfn> (racket-lambda (x) (#<fn:ac-funcall1> acc (#<fn:ac-funcall2> (#<fn:ac-lookup-global> *) 2 x))) (#<fn:ac-lookup-global-arg> args)) (#<fn:rev> g1)))) (racket-lambda ((_ nil)) (racket-begin (racket-set! g1 (#<fn:cons> _ g1)) g1)))) nil)

> (ac-compile '(accum acc :
                 each x args :
                   acc : * 2 x))
((racket-lambda (g1) ((racket-lambda (acc) ((racket-lambda nil (#<fn:eachfn> (racket-lambda (x) (#<fn:ac-funcall1> acc (#<fn:ac-funcall3> (#<fn:ac-lookup-global> *) 2 x (#<fn:rev> g1)))) (#<fn:ac-lookup-global-arg> args))))) (racket-lambda ((_ nil)) (racket-begin (racket-set! g1 (#<fn:cons> _ g1)) g1)))) nil)


> (iso (ac-compile '(accum acc  (each x args  (acc (* 2 x)))))
       (ac-compile '(accum acc : each x args : acc : * 2 x)))
tu


> (let args '(1 2 3 4 5)
    (accum acc
      (each x args
        (acc (* 2 x)))))
(2 4 6 8 10)

> (let args '(1 2 3 4 5)
    (accum acc :
      each x args :
        acc : * 2 x))
(2 4 6 8 10)


;=============================================================================
;  Association lists
;=============================================================================

> (= foo '((b 2) (a 1) (c 3)))
((b 2) (a 1) (c 3))


> foo!a
1

> foo!b
2

> foo!c
3


> foo.0
(b 2)

> foo.1
(a 1)

> foo.2
(c 3)


> (= foo.0 '(b 5))
(b 5)

> foo
((b 5) (a 1) (c 3))


> (= foo!b 10)
10

> foo
((b 10) (a 1) (c 3))


> (= foo!a "bar")
"bar"

> foo
((b 10) (a "bar") (c 3))


> (= foo!a nil)
nil

> foo
((b 10) (c 3))


> (= foo!c nil)
nil

> foo
((b 10))


> (= foo!b nil)
nil

> foo
nil


> (= foo '((b 2) (a 1) (c 3)))
((b 2) (a 1) (c 3))


> (= foo!d nil)
nil

> foo
((b 2) (a 1) (c 3))


> (= foo!d 500)
500

> foo
((d 500) (b 2) (a 1) (c 3))


> (= foo nil)
nil

> foo
nil

> (= foo!d 500)
500

> foo
((d 500))

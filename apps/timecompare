#! /usr/bin/env racket
#lang racket/base

(require racket/cmdline)
(require racket/path)

(define show-compile (make-parameter #f))
(define same-timeit  (make-parameter #t))
(define time         (make-parameter 100))
(define iter         (make-parameter 50))
(define phase        (make-parameter "runtime"))


;; TODO: change joinpath's name in Nu to path
(define (path . args)
  (path->string (normalize-path (apply build-path args))))

(define exec-dir
  (path->string (path-only (normalize-path (find-system-path 'run-file)))))

(define arc3-dir     (make-parameter (path exec-dir "../../../3.1.orig")))
(define ar-dir       (make-parameter (path exec-dir "../../master")))
(define nu-dir       (make-parameter (path exec-dir "../")))
(define lite-nu-dir  (make-parameter (path exec-dir "../../lite nu/")))


(define arguments
  (command-line
    #:program "Arc Time Comparer"
    #:once-each
    [("--compile")             "Shows the compiler output. Doesn't run timing tests"
                               (show-compile #t)]
    [("--individual")          "Uses each runtime's individual compiler for the timeit code"
                               (same-timeit #f)]
    [("-i" "--iterations") int "Number of iterations"
                               (iter (string->number int))]
    [("-t" "--time")       int "Time spent on each iteration, in milliseconds"
                               (time (string->number int))]
    [("--phase")           str "Whether to test runtime/compile/both time speed"
                               (phase str)]
    [("--arc3-dir")        str "Directory where Arc 3.1 is located"
                               (arc3-dir str)]
    [("--ar-dir")          str "Directory where ar is located"
                               (ar-dir str)]
    [("--nu-dir")          str "Directory where nu is located"
                               (nu-dir str)]
    [("--lite-nu-dir")     str "Directory where lite nu is located"
                               (lite-nu-dir str)]
    #:args args
    args))

(when (null? arguments)
  (set! arguments
    '(("(+ 1 2)")
      ("(< 1 2)")
      ("(> 1 2)")
      ;===================================================================
      ("'(1 2)")
      ("(list 1 2)")
      ;===================================================================
      "(car nil)"
      "(car ())"
      "(car '())"
      ;===================================================================
      ("(no '(1 2 3))"
       "(null? '(1 2 3))")
      ;===================================================================
      ("(let a 5 a)"
       "(let ((a 5)) a)")

      ("(let a (list 1 2) (car a))"
       "(let ((a (list 1 2))) (car a))")
      "(let (a b) (list 1 2) a)"
      "(let (a b) (list 1 2) b)"

      ("(let a '(1 2) (car a))"
       "(let ((a '(1 2))) (car a))")
      "(let (a b) '(1 2) a)"
      "(let (a b) '(1 2) b)"
      ;===================================================================
      "(idfn 'x)"
      "(apply idfn '(x))"

      ("'(1 2 3 4 5)")
      ("(list 1 2 3 4 5)")
      ("(apply list 1 2 3 4 (list 5))")
      ;===================================================================
      ("()")
      ("nil" "null")
      ("(list)")
      ;===================================================================
      ("'(foo bar qux)")
      ("`(foo bar qux)")
      ;"#`('foo 'bar 'qux)"
      ("(list 'foo 'bar 'qux)")
      ;===================================================================
      ("(obj foo 5)"
       "(make-hash 'foo 5)")
      ("(let name (obj foo 5) name!foo)"
       "(let ((name (make-hash 'foo 5))) (hash-ref name 'foo))")
      ;===================================================================
      "(do1 10 20)"
      "(after 10 20)"
      ;===================================================================
      ("(rev '(1 2 3 4 5))"
       "(reverse '(1 2 3 4 5))")
      ("(rev (list 1 2 3 4 5))"
       "(reverse (list 1 2 3 4 5))")
      ;===================================================================
      ("(join '(1 2) '(3 4))"
       "(append '(1 2) '(3 4))")
      ("(join (list 1 2) (list 3 4))"
       "(append (list 1 2) (list 3 4))")
      ;===================================================================
;;TODO: fix this "(let bb (n-of 1000 (rand 50)) (bestn 100 > bb) nil)"
;;TODO: fix this "(let td (n-of 10000 (rand 100)) (sort < td) nil)"

      ("(rand 50)"
       "(random 50)")
;;TODO: fix this "(bestn 11 > '(1 2 3 4 5 6 7 8 9 10))"
      )))


(define-syntax-rule (w/ dir name space body ...)
  (begin (define name space)
         (parameterize ((current-namespace name)
                        (current-directory (dir))
                        (current-readtable (current-readtable)))
           body ... (void))))

#|;; TODO: maybe use different code for ar, like unquoting the macros/fns...?
(define (make-timeit)
  ;; TODO: get rid of this 'do
  '(do (mac timeit1 (x limit)
         (w/uniq (u n time gc mem)
           `(with (,n     0
                   ,time  (msec)
                   ,gc    (,current-gc-milliseconds)
                   ,mem   (,current-memory-use))
              ((rfn ,u ()
                 ,x
                 (++ ,n)
                 (when (< (- (msec) ,time) ,limit)
                   (,u))))
             (list ,n
                    (- (,current-gc-milliseconds) ,gc)
                    (- (,current-memory-use)  ,mem)))))

       #|(mac timeit (x (o limit 10000))
         (w/uniq (a b c)
           `(let (a b c) (timeit1 ,x ,limit)
              (prn "iter: "   (num a)
                   "  gc: "   b
                   "  mem: "  c)
              nil)))|#
       ))|#

#|(define (make-timeit)
  (eval `(define-syntax-rule (time-timeit1 x limit)
           (let ((n     0)
                 (time  (,current-milliseconds))
                 (gc    (,current-gc-milliseconds))
                 (mem   (,current-memory-use)))
             (let loop ()
               x
               (set! n (+ n 1))
               (when (< (- (,current-milliseconds) time) limit)
                 (loop)))
             (list n
                   (- (current-gc-milliseconds) gc)
                   (- (current-memory-use)      mem))))))|#


(w/ current-directory racket-namespace (make-base-namespace)
  ;(make-timeit)
  )

(w/ arc3-dir arc3-namespace (make-base-empty-namespace)
  (namespace-require 'mzscheme)
  (namespace-require "ac.scm")
  (namespace-require "brackets.scm")
  (eval '(use-bracket-readtable))
  (eval '(aload "arc.arc"))

  ;(make-timeit)
  ;(namespace-require '(prefix timecompare- racket/base))

  ;(cond ((same-timeit)
          (namespace-require '(prefix racket- racket/base))
          (eval '(define nil _nil))
  #|        )
        (else
          ;(displayln `(ac ',(make-timeit) '()))
          (eval '(aload "strings.arc"))
          #|(eval `(_eval '(= gc-msec      current-gc-milliseconds
                            process-msec current-process-milliseconds)))|#
          (eval `(_eval ',(make-timeit ;current-gc-milliseconds
                                       ;current-process-milliseconds
                                       ;memory
                                       )))))|#
  ;((namespace-variable-value 'use-bracket-readtable))
  ;((namespace-variable-value 'aload) "arc.arc")
  )


                        ;; TODO: ew
(w/ ar-dir ar-namespace (begin (namespace-require `(file ,(path (ar-dir) "run.ss")))
                               ((namespace-variable-value 'new-runtime)
                                (mcons (ar-dir) 'nil)))
  (eval '(use-apply "arc"))

  ;(namespace-require 'racket/base)
  ;(make-timeit)
  ;(namespace-require '(prefix timecompare- racket/base))

  #|(unless (same-timeit)
    (eval '(use-apply "strings"))
    ;((namespace-variable-value 'use-apply) "arc")
    #|(eval `(eval (ar-toarc (racket-quote
             (= gc-msec      racket-current-gc-milliseconds
                process-msec racket-current-process-milliseconds
                memory       racket-current-memory-use)))))|#
    (eval `(eval (ar-toarc (racket-quote ,(make-timeit))))))|#
  )


;; TODO: this whole blob should be a *lot* shorter, like by importing the
;;       "arc" file or something
(w/ nu-dir nu-namespace (make-base-empty-namespace)
  (define (ac-require-base)
    (namespace-require/expansion-time '(only racket/private/pre-base
                                         #%app #%top #%datum #%top-interaction))
    (namespace-require/copy '(prefix racket- racket/base)))

  (ac-require-base)

  ;(namespace-set-variable-value! 'exec-dir*       (nu-dir)        #f)
  ;(namespace-set-variable-value! 'ac-require-base ac-require-base #f)

  (load/use-compiled "01 compiler.arc")

  (eval `(ac-init ,(nu-dir) ,ac-require-base))
  ;(eval '(importfn1 "strings")) ;; TODO
  (eval '(importfn1 "time"))

  ;(namespace-require 'racket/base)
  ;(make-timeit)

  ;(namespace-require '(prefix timecompare- racket/base))

  #|(eval '(racket-begin (ac-load "02 core.arc")
                       (ac-load "03 ssyntax.arc")
                       (ac-load "04 arc.arc")
                       (ac-load "05 import.arc")
                       (ac-load "06 extra.arc")
                       (ac-load "lib/time.arc")))|#

  #|(let ((ac-load (namespace-variable-value 'ac-load #f)))
    (ac-load "02 core.arc")
    (ac-load "03 ssyntax.arc")
    (ac-load "04 arc.arc")
    (ac-load "05 import.arc")
    (ac-load "06 extra.arc")
    (ac-load "lib/time.arc"))|#
  )


(w/ lite-nu-dir lite-nu-namespace (make-base-empty-namespace)
  (namespace-require '(file "01 nu.rkt"))
  (eval `(init ,(lite-nu-dir)))

  ;(make-timeit)

  ;(namespace-require '(prefix timecompare- racket/base))
  (namespace-require '(prefix racket- racket/base))
  )


(define (percent x y)
  (* (/ (- y x) x) 100)
  ;(* -100 (/ (- x y) y))
  #|(if (< x y)
      (* 10 (/ y x))
      (* -10 (/ x y)))|#
  ;(- (* (/ y x) 100) 100)
  )

;(displayln (eval '(syntax->datum (expand `(time-timeit1 ,(ac '(+ 1 2)) 10000))) lite-nu-namespace))

;(exit)


(define (nu-compile x)
  (eval `(ac-compile (racket-quote ,x)) nu-namespace))

(define (nu-eval x)
  (eval (nu-compile x) nu-namespace))


(define first-iter (make-parameter #t))
(define prev-iter  (make-parameter 0))

(define (timeit-args x)
  (first-iter #t)
  (prev-iter 0)
  (lambda (xs)
    ;; TODO: some sorta matching code
    (let ((prompt   (car xs))
          (read     (cadr xs))
          (compile  (caddr xs))
          ;(quoter   (cadddr xs))
          (space    (cadddr xs)))
      ;(display prompt)
      (let* (;(val   (compile (read x)))
             ;; TODO: kinda ew how it has expr twice in the let*
             (expr  (eval (read x) space))
             (val   (compile expr))
             (expr  (cond
                      ((equal? (phase) "runtime")
                        (set! val (eval val space))
                        ;`(time-timeit1 ,val ,(time))
                        (if (same-timeit)
                              (nu-compile `(timeit1 (% ,val) ,(time)))
                            (eval ;(compile (read (string-append "(timeit1 " x " " (time) ")")))
                                  ;(compile `(timeit1 ,(read x) ,(time)))
                                  (compile `(timeit1 ,expr ,(time)))
                                  ;(f (string-append "(timeit1 " x " " (time) ")"))
                                  space))
                        )
                      ((equal? (phase) "compile")
                        ;`(time-timeit1 ,val ,(time))
                        ;(set! val (compile (read x)))
                        (if (same-timeit)
                              (nu-compile `(timeit1 (% ,val) ,(time)))
                            (eval (compile `(timeit1 ,val ,(time)))
                                  ;(f (string-append "(timeit1 " val " " (time) ")"))
                                  space))
                        )
                      ((equal? (phase) "both")
                        ;(write )
                        ;(newline)
                        (set! val (eval (compile (eval (read (string-append "(eval (quote " x "))")) space))
                                        ;(compile `'(eval (read ,x)))
                                        ;(compile (read x) `(eval (,quoter ,expr)))
                                        ;(f (string-append "(eval (quote " x "))"))
                                        space))
                        ;`(time-timeit1 ,val ,(time))
                        (if (same-timeit)
                              (nu-compile `(timeit1 (% ,val) ,(time)))
                            (eval (compile `(timeit1 ,val ,(time)))
                                  ;(f (string-append "(timeit1 " val " " (time) ")"))
                                  space))
                        ))))

        (display prompt)
        (display "eval: ")
        (write (eval val space))
        (newline)
        ;(display "time: ")
        (if (show-compile)
              (begin (display "compile: ")
                     (write (if (same-timeit) val expr))
                     (newline))
            (let loop ((x    (iter))
                       (acc  null))
              (if (> x 0)
                    ;(display " ")
                    (let ((expr (eval expr space)))
                      (loop (- x 1) (cons expr acc)))
                                               ;racket-exact->inexact

                                                  ;(map median (apply zip (n-of 50 (timeit1 x 100))))
                  ;; TODO: this whole thing is hacky
                  (let ((n (nu-eval `(let (a b c) (map median (apply zip ',acc)) ;round:avg
                                       (prn "iter: "    (commafy a)
                                            "  gc: "    b
                                            "  mem: "   c
                                                        ;; TODO: ew
                                            "  diff: "  (if (is ,(prev-iter) 0)
                                                              0
                                                                     ;; TODO: write a function for this
                                                            (commafy (percent ,(prev-iter) a))) "%")
                                       a))))
                    (when (eq? (first-iter) #t)
                      (first-iter #f)
                      (prev-iter n)
                      ;(prev-iter 0)
                      )
                      #|(displayln (apply map (lambda args
                                    (displayln args)
                                   (eval `(avg (racket-quote ,args)) nu-namespace))
                                 acc))|#
                                 ))))))
                    #|(display "iter: ")
                    (display (eval `(commafy ,(car expr)) nu-namespace))
                    (display "  gc: ")
                    (display (cadr expr))
                    (display "  mem: ")
                    (displayln (caddr expr))|#
    (newline)))

(define (timeit . args)
  ;; TODO: ew code duplication
  (displayln (make-string 78 #\=))
  (newline)
  (parameterize ((first-iter  #t)
                 (prev-iter   0))
    (for-each (lambda (x)
                (unless (equal? x "")
                  (when (pair? x)
                    (set! x (car x)))
                  (display "> " )
                  (displayln x)
                  ;(parameterize () )
                  (for-each (timeit-args x) args)
                  (displayln (make-string 78 #\=))
                  (newline)))
              arguments)))

(timeit (list "   arc3 " (lambda (x) `(_read ,x))
                         (lambda (x) `(ac ',x '()))
                         ;'quote
                         arc3-namespace)
        (list "     ar " (lambda (x) `(read ,x))
                         (lambda (x) `(ar-deep-fromarc (ac (racket-quote ,x) (racket-quote nil))))
                         ;'racket-quote
                         ar-namespace)
        (list " old nu " (lambda (x) `(read ,x))
                         (lambda (x) `(ac-compile (racket-quote ,x)))
                         ;'racket-quote
                         nu-namespace)
        (list " new nu " (lambda (x) `((var 'read) ,x))
                         (lambda (x) `(ac ',x))
                         ;'racket-quote
                         lite-nu-namespace))

;; This is to prevent () from being printed when the REPL exits
;(void)

#|
echo "(+ 1 2)
(< 1 2)
(> 1 2)

(let a 5 a)

(let a (list 1 2) (car a))
(let (a b) (list 1 2) a)
(let (a b) (list 1 2) b)

(let a '(1 2) (car a))
(let (a b) '(1 2) a)
(let (a b) '(1 2) b)" | xargs -d "\n" -- ./apps/timecompare -t 100 > "notes/timing comparison2.md"

 -I '{}' '{}'
|#


#|
./apps/timecompare --phase runtime > "timing/timing comparison" &&
./apps/timecompare --phase compile > "timing/timing comparison (compile)" &&
./apps/timecompare --phase both    > "timing/timing comparison (both)"
|#
